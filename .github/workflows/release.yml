# TermiVoxed Release Pipeline
# Author: Santhosh T / LxusBrain
#
# Sophisticated release automation that:
# - Validates dependencies and runs tests
# - Builds native apps for Windows, macOS, Linux
# - Creates signed installers (Windows: Inno Setup, macOS: DMG)
# - Generates checksums and manifests
# - Publishes to GitHub Releases
#
# Trigger: Push a version tag (v1.0.0) or manual workflow dispatch

name: Release

on:
  push:
    tags: ["v*.*.*"]
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 1.0.0)"
        required: true
        type: string
      prerelease:
        description: "Mark as pre-release"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "Skip running tests"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  packages: write
  pull-requests: read

env:
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "20"

jobs:
  # ============================================================================
  # Job 1: Prepare Release - Validate and determine version
  # ============================================================================
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      changelog: ${{ steps.changelog.outputs.changelog }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            IS_PRERELEASE="${{ github.event.inputs.prerelease }}"
          else
            VERSION="${GITHUB_REF_NAME#v}"
            if [[ "$VERSION" == *"alpha"* ]] || [[ "$VERSION" == *"beta"* ]] || [[ "$VERSION" == *"rc"* ]]; then
              IS_PRERELEASE="true"
            else
              IS_PRERELEASE="false"
            fi
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "::notice::Releasing version $VERSION (prerelease: $IS_PRERELEASE)"

      - name: Generate changelog
        id: changelog
        continue-on-error: true
        uses: mikepenz/release-changelog-builder-action@v4
        with:
          configuration: |
            {
              "categories": [
                {"title": "## New Features", "labels": ["feature", "enhancement"]},
                {"title": "## Bug Fixes", "labels": ["bug", "fix"]},
                {"title": "## Security", "labels": ["security"]},
                {"title": "## Performance", "labels": ["performance"]},
                {"title": "## Documentation", "labels": ["documentation", "docs"]},
                {"title": "## Other Changes", "labels": []}
              ],
              "template": "#{{CHANGELOG}}\n\n**Full Changelog**: #{{RELEASE_DIFF}}"
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create release notes
        run: |
          mkdir -p artifacts
          cat << 'EOF' > artifacts/RELEASE_NOTES.md
          # TermiVoxed v${{ steps.version.outputs.version }}

          ${{ steps.changelog.outputs.changelog }}

          ## Installation

          ### Windows
          1. Download `TermiVoxed-${{ steps.version.outputs.version }}-Setup.exe`
          2. Run the installer and follow the prompts
          3. Launch TermiVoxed from the Start Menu

          ### macOS
          1. Download `TermiVoxed-${{ steps.version.outputs.version }}-macos.dmg`
          2. Open the DMG and drag TermiVoxed to Applications
          3. Right-click and select "Open" on first launch

          ### Linux
          1. Download `TermiVoxed-${{ steps.version.outputs.version }}-linux-x64.tar.gz`
          2. Extract: `tar -xzf TermiVoxed-*.tar.gz`
          3. Run: `./TermiVoxed/TermiVoxed`

          ## Verification
          SHA256 checksums are provided in `checksums.txt`.
          EOF

      - name: Upload release notes
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: artifacts/

  # ============================================================================
  # Job 2: Run Tests (unless skipped)
  # ============================================================================
  test:
    name: Pre-Release Tests
    runs-on: ubuntu-latest
    needs: [prepare]
    if: ${{ github.event.inputs.skip_tests != 'true' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: web_ui/frontend/package-lock.json

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio flake8 mypy

      - name: Run Python linting
        run: |
          echo "::group::Flake8 Linting"
          flake8 --max-line-length=120 --exclude=.git,__pycache__,build,dist,venv backend core models utils || true
          echo "::endgroup::"

      - name: Run Python type check
        run: |
          echo "::group::MyPy Type Check"
          mypy --ignore-missing-imports backend core || true
          echo "::endgroup::"

      - name: Run Python tests
        run: |
          echo "::group::Python Unit Tests"
          pytest tests/ -v --tb=short || echo "::warning::Some tests failed"
          echo "::endgroup::"

      - name: Install frontend dependencies
        working-directory: web_ui/frontend
        run: npm ci

      - name: Run frontend lint
        working-directory: web_ui/frontend
        run: |
          echo "::group::Frontend Linting"
          npm run lint || true
          echo "::endgroup::"

      - name: Run frontend type check
        working-directory: web_ui/frontend
        run: |
          echo "::group::Frontend Type Check"
          npx tsc --noEmit
          echo "::endgroup::"

  # ============================================================================
  # Job 3: Build Windows Application
  # ============================================================================
  build-windows:
    name: Build Windows
    runs-on: windows-latest
    needs: [prepare, test]
    if: ${{ always() && needs.prepare.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped') }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: web_ui/frontend/package-lock.json

      - name: Install Inno Setup
        run: |
          choco install innosetup -y
          echo "C:\Program Files (x86)\Inno Setup 6" >> $env:GITHUB_PATH

      - name: Bundle FFmpeg
        run: |
          echo "::group::Bundling FFmpeg for Windows"
          python build_tools/bundle_ffmpeg.py --platform windows
          echo "::endgroup::"

      - name: Verify FFmpeg Bundle
        run: |
          echo "::group::Verifying FFmpeg bundle"
          if (!(Test-Path "vendor/ffmpeg/windows/bin/ffmpeg.exe")) {
            Write-Error "FFmpeg not bundled! vendor/ffmpeg/windows/bin/ffmpeg.exe not found"
            exit 1
          }
          if (!(Test-Path "vendor/ffmpeg/windows/bin/ffprobe.exe")) {
            Write-Error "FFprobe not bundled! vendor/ffmpeg/windows/bin/ffprobe.exe not found"
            exit 1
          }
          Write-Host "FFmpeg bundle verified successfully"
          & vendor/ffmpeg/windows/bin/ffmpeg.exe -version
          echo "::endgroup::"
        shell: pwsh

      - name: Install Python dependencies
        run: |
          echo "::group::Installing Python dependencies"
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
          echo "::endgroup::"

      - name: Build frontend
        working-directory: web_ui/frontend
        run: |
          echo "::group::Building frontend"
          npm ci
          npm run build
          echo "::endgroup::"

      - name: Update version in pyproject.toml
        run: |
          $content = Get-Content pyproject.toml -Raw
          $content = $content -replace 'version = ".*"', 'version = "${{ needs.prepare.outputs.version }}"'
          Set-Content pyproject.toml $content
        shell: pwsh

      - name: Build Windows executable
        run: |
          echo "::group::Building Windows executable"

          # Create directories
          New-Item -ItemType Directory -Force -Path dist\windows
          New-Item -ItemType Directory -Force -Path build\windows\work

          # Check if spec file exists
          $specFile = "build_tools\windows\termivoxed.spec"
          if (Test-Path $specFile) {
            pyinstaller --clean `
              --workpath build\windows\work `
              --distpath dist\windows `
              $specFile
          } else {
            # Use launcher.py as entry point - it starts the FastAPI backend and opens browser
            # NOT main.py which is a CLI application requiring console
            pyinstaller --name TermiVoxed `
              --onedir `
              --windowed `
              --icon assets\icons\icon.ico `
              --distpath dist\windows `
              --add-data "web_ui/frontend/dist;web_ui/frontend/dist" `
              --add-data "web_ui/api;web_ui/api" `
              --add-data "backend;backend" `
              --add-data "core;core" `
              --add-data "models;models" `
              --add-data "subscription;subscription" `
              --add-data "utils;utils" `
              --add-data "vendor/ffmpeg/windows;vendor/ffmpeg/windows" `
              --hidden-import=uvicorn.logging `
              --hidden-import=uvicorn.loops `
              --hidden-import=uvicorn.loops.auto `
              --hidden-import=uvicorn.protocols `
              --hidden-import=uvicorn.protocols.http `
              --hidden-import=uvicorn.protocols.http.auto `
              --hidden-import=uvicorn.protocols.websockets `
              --hidden-import=uvicorn.protocols.websockets.auto `
              --hidden-import=uvicorn.lifespan `
              --hidden-import=uvicorn.lifespan.on `
              --hidden-import=fastapi `
              --hidden-import=starlette `
              --hidden-import=pydantic `
              --collect-submodules=web_ui.api `
              build_tools/desktop/launcher.py
          }

          echo "::endgroup::"
        shell: pwsh

      - name: Create Inno Setup installer
        run: |
          echo "::group::Creating Windows installer"

          $version = "${{ needs.prepare.outputs.version }}"
          $workDir = (Get-Location).Path
          $distDir = "$workDir\dist\windows\TermiVoxed"
          $releaseDir = "$workDir\release"

          # Debug: Show what exists
          echo "Working directory: $workDir"
          echo "Looking for dist directory..."
          Get-ChildItem -Path "dist" -Recurse -Depth 2 | Select-Object FullName

          # Create Inno Setup script with absolute paths
          $issContent = @"
          [Setup]
          AppId={{B5A7C8D9-E6F1-4A2B-8C3D-E4F5A6B7C8D9}}
          AppName=TermiVoxed
          AppVersion=$version
          AppPublisher=LxusBrain
          AppPublisherURL=https://lxusbrain.com
          DefaultDirName={autopf}\TermiVoxed
          DisableProgramGroupPage=yes
          OutputDir=$releaseDir
          OutputBaseFilename=TermiVoxed-$version-Setup
          Compression=lzma2/ultra64
          SolidCompression=yes
          WizardStyle=modern
          PrivilegesRequired=lowest
          PrivilegesRequiredOverridesAllowed=dialog

          [Languages]
          Name: "english"; MessagesFile: "compiler:Default.isl"

          [Tasks]
          Name: "desktopicon"; Description: "Create a desktop shortcut"; GroupDescription: "Additional icons:"

          [Files]
          Source: "$distDir\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs

          [Icons]
          Name: "{autoprograms}\TermiVoxed"; Filename: "{app}\TermiVoxed.exe"
          Name: "{autodesktop}\TermiVoxed"; Filename: "{app}\TermiVoxed.exe"; Tasks: desktopicon

          [Run]
          Filename: "{app}\TermiVoxed.exe"; Description: "Launch TermiVoxed"; Flags: nowait postinstall skipifsilent
          "@

          New-Item -ItemType Directory -Force -Path build\windows
          New-Item -ItemType Directory -Force -Path release
          Set-Content -Path "build\windows\installer.iss" -Value $issContent

          # Show the generated script for debugging
          echo "Generated installer.iss:"
          Get-Content "build\windows\installer.iss"

          # Run Inno Setup
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" "build\windows\installer.iss"

          # Also create a zip for portable version
          if (Test-Path $distDir) {
            Compress-Archive -Path "$distDir\*" -DestinationPath "release\TermiVoxed-$version-windows-x64-portable.zip"
          }

          echo "::endgroup::"
        shell: pwsh

      - name: Generate checksums
        run: |
          cd release
          Get-ChildItem -File | ForEach-Object {
            $hash = (Get-FileHash $_.Name -Algorithm SHA256).Hash.ToLower()
            "$hash  $($_.Name)" | Out-File -Append checksums-windows.txt
          }
          Get-Content checksums-windows.txt
        shell: pwsh

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: release/
          retention-days: 30

  # ============================================================================
  # Job 4: Build macOS Application
  # ============================================================================
  build-macos:
    name: Build macOS
    runs-on: macos-latest
    needs: [prepare, test]
    if: ${{ always() && needs.prepare.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped') }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: web_ui/frontend/package-lock.json

      - name: Bundle FFmpeg
        run: |
          echo "::group::Bundling FFmpeg for macOS"
          python build_tools/bundle_ffmpeg.py --platform macos
          echo "::endgroup::"

      - name: Verify FFmpeg Bundle
        run: |
          echo "::group::Verifying FFmpeg bundle"
          if [ ! -f "vendor/ffmpeg/macos/bin/ffmpeg" ]; then
            echo "ERROR: FFmpeg not bundled! vendor/ffmpeg/macos/bin/ffmpeg not found"
            exit 1
          fi
          if [ ! -f "vendor/ffmpeg/macos/bin/ffprobe" ]; then
            echo "ERROR: FFprobe not bundled! vendor/ffmpeg/macos/bin/ffprobe not found"
            exit 1
          fi
          echo "FFmpeg bundle verified successfully"
          chmod +x vendor/ffmpeg/macos/bin/ffmpeg vendor/ffmpeg/macos/bin/ffprobe
          vendor/ffmpeg/macos/bin/ffmpeg -version
          echo "::endgroup::"

      - name: Install Python dependencies
        run: |
          echo "::group::Installing Python dependencies"
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
          echo "::endgroup::"

      - name: Build frontend
        working-directory: web_ui/frontend
        run: |
          echo "::group::Building frontend"
          npm ci
          npm run build
          echo "::endgroup::"

      - name: Update version
        run: |
          sed -i '' "s/version = \".*\"/version = \"${{ needs.prepare.outputs.version }}\"/" pyproject.toml

      - name: Build macOS app
        run: |
          echo "::group::Building macOS application"

          mkdir -p dist/macos release

          # Use launcher.py as entry point - it starts the FastAPI backend and opens browser
          # NOT main.py which is a CLI application requiring console
          pyinstaller --name TermiVoxed \
            --onedir \
            --windowed \
            --icon assets/icons/icon.icns \
            --osx-bundle-identifier com.lxusbrain.termivoxed \
            --distpath dist/macos \
            --add-data "web_ui/frontend/dist:web_ui/frontend/dist" \
            --add-data "web_ui/api:web_ui/api" \
            --add-data "backend:backend" \
            --add-data "core:core" \
            --add-data "models:models" \
            --add-data "subscription:subscription" \
            --add-data "utils:utils" \
            --add-data "vendor/ffmpeg/macos:vendor/ffmpeg/macos" \
            --hidden-import=uvicorn.logging \
            --hidden-import=uvicorn.loops \
            --hidden-import=uvicorn.loops.auto \
            --hidden-import=uvicorn.protocols \
            --hidden-import=uvicorn.protocols.http \
            --hidden-import=uvicorn.protocols.http.auto \
            --hidden-import=uvicorn.protocols.websockets \
            --hidden-import=uvicorn.protocols.websockets.auto \
            --hidden-import=uvicorn.lifespan \
            --hidden-import=uvicorn.lifespan.on \
            --hidden-import=fastapi \
            --hidden-import=starlette \
            --hidden-import=pydantic \
            --collect-submodules=web_ui.api \
            build_tools/desktop/launcher.py

          echo "::endgroup::"

      - name: Sign macOS app (if certificate available)
        if: ${{ env.APPLE_DEVELOPER_ID != '' }}
        env:
          APPLE_DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
        run: |
          echo "::group::Signing macOS application"
          codesign --force --deep --sign "$APPLE_DEVELOPER_ID" \
            --options runtime --timestamp \
            dist/macos/TermiVoxed.app
          echo "::endgroup::"

      - name: Create DMG
        run: |
          echo "::group::Creating DMG"

          VERSION="${{ needs.prepare.outputs.version }}"

          if [ -d "dist/macos/TermiVoxed.app" ]; then
            hdiutil create -volname "TermiVoxed" \
              -srcfolder dist/macos/TermiVoxed.app \
              -ov -format UDZO \
              "release/TermiVoxed-${VERSION}-macos.dmg"
          elif [ -d "dist/macos/TermiVoxed" ]; then
            # Create app structure from folder
            mkdir -p "dist/macos/TermiVoxed.app/Contents/MacOS"
            cp -R dist/macos/TermiVoxed/* "dist/macos/TermiVoxed.app/Contents/MacOS/"
            hdiutil create -volname "TermiVoxed" \
              -srcfolder dist/macos/TermiVoxed.app \
              -ov -format UDZO \
              "release/TermiVoxed-${VERSION}-macos.dmg"
          fi

          # Also create a tar.gz for direct download
          if [ -d "dist/macos/TermiVoxed" ]; then
            tar -czvf "release/TermiVoxed-${VERSION}-macos-x64.tar.gz" \
              -C dist/macos TermiVoxed
          fi

          echo "::endgroup::"

      - name: Generate checksums
        run: |
          cd release
          shasum -a 256 * > checksums-macos.txt
          cat checksums-macos.txt

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: release/
          retention-days: 30

  # ============================================================================
  # Job 5: Build Linux Application
  # ============================================================================
  build-linux:
    name: Build Linux
    runs-on: ubuntu-latest
    needs: [prepare, test]
    if: ${{ always() && needs.prepare.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped') }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: web_ui/frontend/package-lock.json

      - name: Install system dependencies
        run: |
          echo "::group::Installing system dependencies"
          sudo apt-get update
          sudo apt-get install -y libsdl2-dev
          echo "::endgroup::"

      - name: Bundle FFmpeg
        run: |
          echo "::group::Bundling FFmpeg for Linux"
          python3 build_tools/bundle_ffmpeg.py --platform linux
          echo "::endgroup::"

      - name: Verify FFmpeg Bundle
        run: |
          echo "::group::Verifying FFmpeg bundle"
          if [ ! -f "vendor/ffmpeg/linux/bin/ffmpeg" ]; then
            echo "ERROR: FFmpeg not bundled! vendor/ffmpeg/linux/bin/ffmpeg not found"
            exit 1
          fi
          if [ ! -f "vendor/ffmpeg/linux/bin/ffprobe" ]; then
            echo "ERROR: FFprobe not bundled! vendor/ffmpeg/linux/bin/ffprobe not found"
            exit 1
          fi
          echo "FFmpeg bundle verified successfully"
          chmod +x vendor/ffmpeg/linux/bin/ffmpeg vendor/ffmpeg/linux/bin/ffprobe
          vendor/ffmpeg/linux/bin/ffmpeg -version
          echo "::endgroup::"

      - name: Install Python dependencies
        run: |
          echo "::group::Installing Python dependencies"
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
          echo "::endgroup::"

      - name: Build frontend
        working-directory: web_ui/frontend
        run: |
          echo "::group::Building frontend"
          npm ci
          npm run build
          echo "::endgroup::"

      - name: Update version
        run: |
          sed -i "s/version = \".*\"/version = \"${{ needs.prepare.outputs.version }}\"/" pyproject.toml

      - name: Build Linux executable
        run: |
          echo "::group::Building Linux executable"

          mkdir -p dist/linux release

          # Use launcher.py as entry point - it starts the FastAPI backend and opens browser
          # NOT main.py which is a CLI application requiring console
          pyinstaller --name TermiVoxed \
            --onedir \
            --distpath dist/linux \
            --add-data "web_ui/frontend/dist:web_ui/frontend/dist" \
            --add-data "web_ui/api:web_ui/api" \
            --add-data "backend:backend" \
            --add-data "core:core" \
            --add-data "models:models" \
            --add-data "subscription:subscription" \
            --add-data "utils:utils" \
            --add-data "vendor/ffmpeg/linux:vendor/ffmpeg/linux" \
            --hidden-import=uvicorn.logging \
            --hidden-import=uvicorn.loops \
            --hidden-import=uvicorn.loops.auto \
            --hidden-import=uvicorn.protocols \
            --hidden-import=uvicorn.protocols.http \
            --hidden-import=uvicorn.protocols.http.auto \
            --hidden-import=uvicorn.protocols.websockets \
            --hidden-import=uvicorn.protocols.websockets.auto \
            --hidden-import=uvicorn.lifespan \
            --hidden-import=uvicorn.lifespan.on \
            --hidden-import=fastapi \
            --hidden-import=starlette \
            --hidden-import=pydantic \
            --collect-submodules=web_ui.api \
            build_tools/desktop/launcher.py

          echo "::endgroup::"

      - name: Create archive
        run: |
          echo "::group::Creating archive"
          VERSION="${{ needs.prepare.outputs.version }}"

          tar -czvf "release/TermiVoxed-${VERSION}-linux-x64.tar.gz" \
            -C dist/linux TermiVoxed

          echo "::endgroup::"

      - name: Generate checksums
        run: |
          cd release
          sha256sum * > checksums-linux.txt
          cat checksums-linux.txt

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-build
          path: release/
          retention-days: 30

  # ============================================================================
  # Job 6: Build Python Package
  # ============================================================================
  build-python:
    name: Build Python Package
    runs-on: ubuntu-latest
    needs: [prepare]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Update version
        run: |
          sed -i "s/version = \".*\"/version = \"${{ needs.prepare.outputs.version }}\"/" pyproject.toml

      - name: Build package
        run: python -m build

      - name: Upload Python package
        uses: actions/upload-artifact@v4
        with:
          name: python-package
          path: dist/

  # ============================================================================
  # Job 7: Create GitHub Release
  # ============================================================================
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare, build-windows, build-macos, build-linux, build-python]
    if: ${{ always() && needs.prepare.result == 'success' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release-assets

          echo "::group::Collecting artifacts"

          # Copy all build artifacts
          for dir in artifacts/*/; do
            if [ -d "$dir" ]; then
              echo "Processing: $dir"
              cp -v "$dir"* release-assets/ 2>/dev/null || true
            fi
          done

          # Merge checksums
          echo "Generating combined checksums..."
          cd release-assets
          cat checksums-*.txt 2>/dev/null | sort -u > checksums.txt || true
          rm -f checksums-*.txt

          echo "Final checksums:"
          cat checksums.txt || echo "No checksums generated"

          echo "::endgroup::"

          echo "::group::Release assets"
          ls -la .
          echo "::endgroup::"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: TermiVoxed v${{ needs.prepare.outputs.version }}
          tag_name: v${{ needs.prepare.outputs.version }}
          body_path: artifacts/release-notes/RELEASE_NOTES.md
          draft: false
          prerelease: ${{ needs.prepare.outputs.is_prerelease == 'true' }}
          files: release-assets/*
          fail_on_unmatched_files: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Pre-release:** ${{ needs.prepare.outputs.is_prerelease }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Windows | ${{ needs.build-windows.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| macOS | ${{ needs.build-macos.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Linux | ${{ needs.build-linux.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Python | ${{ needs.build-python.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ls -la release-assets/ >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Job 8: Deploy Cloud Functions (production releases only)
  # ============================================================================
  deploy-functions:
    name: Deploy Cloud Functions
    runs-on: ubuntu-latest
    needs: [prepare, release]
    if: ${{ needs.prepare.outputs.is_prerelease != 'true' }}

    steps:
      - name: Check Firebase token
        id: check-token
        run: |
          if [ -z "${{ secrets.FIREBASE_TOKEN }}" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "::warning::FIREBASE_TOKEN not configured, skipping deployment"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        if: steps.check-token.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Set up Node.js
        if: steps.check-token.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Install Firebase CLI
        if: steps.check-token.outputs.skip != 'true'
        run: npm install -g firebase-tools

      - name: Install function dependencies
        if: steps.check-token.outputs.skip != 'true'
        working-directory: cloud_functions/functions
        run: npm ci

      - name: Deploy to Firebase
        if: steps.check-token.outputs.skip != 'true'
        run: firebase deploy --only functions --token "${{ secrets.FIREBASE_TOKEN }}"
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
