import { useState, useEffect, useMemo } from 'react'
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { motion, AnimatePresence } from 'framer-motion'
import {
  Sparkles,
  X,
  Loader2,
  Check,
  AlertTriangle,
  RefreshCw,
  Wand2,
  Settings,
  ChevronDown,
  Clock,
  FileText,
  Zap,
  LayoutGrid,
  Film,
  Edit3,
  Trash2,
  Plus,
  Eye,
  Video,
} from 'lucide-react'
import { llmApi, segmentsApi } from '../api/client'
import { useAppStore } from '../stores/appStore'
import type { OllamaModel, GeneratedScript, SegmentDescription, AutoGeneratedSegment, VideoInfo } from '../types'
import toast from 'react-hot-toast'
import clsx from 'clsx'

interface AIScriptGeneratorProps {
  projectName: string
  videoId: string
  videoDuration: number
  isOpen: boolean
  onClose: () => void
  // Multi-video support
  videos?: VideoInfo[]
  // Video path for AI analysis
  videoPath?: string
}

type VideoScope = 'current' | 'all' | string // 'current', 'all', or specific video ID

type ProviderType = 'ollama' | 'openai' | 'anthropic' | 'google' | 'custom'
type GenerationMode = 'manual' | 'auto'

interface SegmentInput {
  id: string
  startTime: number
  endTime: number
  description: string
}

export default function AIScriptGenerator({
  projectName,
  videoId,
  videoDuration,
  isOpen,
  onClose,
  videos = [],
  videoPath,
}: AIScriptGeneratorProps) {
  const queryClient = useQueryClient()
  const { segments: existingSegments, setSegments, isGeneratingScript, setIsGeneratingScript } = useAppStore()

  // Multi-video support
  const hasMultipleVideos = videos.length > 1
  const [videoScope, setVideoScope] = useState<VideoScope>('current')

  // Video Analysis State
  const [useVideoAnalysis, setUseVideoAnalysis] = useState(false)
  const [visionModel, setVisionModel] = useState('qwen3-vl:8b')

  // Get target video(s) based on scope
  const getTargetVideos = useMemo(() => {
    if (videoScope === 'current') {
      const currentVideo = videos.find(v => v.id === videoId)
      return currentVideo ? [currentVideo] : []
    } else if (videoScope === 'all') {
      return videos.filter(v => v.file_exists)
    } else {
      // Specific video ID
      const specificVideo = videos.find(v => v.id === videoScope)
      return specificVideo ? [specificVideo] : []
    }
  }, [videoScope, videoId, videos])

  // Get effective duration based on scope
  const effectiveDuration = useMemo(() => {
    if (videoScope === 'current') return videoDuration
    if (videoScope === 'all') {
      // Total duration of all videos
      return videos.reduce((sum, v) => sum + (v.duration || 0), 0)
    }
    // Specific video
    const video = videos.find(v => v.id === videoScope)
    return video?.duration || videoDuration
  }, [videoScope, videoDuration, videos])

  // Get effective video ID for segment creation
  const getEffectiveVideoId = () => {
    if (videoScope === 'current') return videoId
    if (videoScope === 'all') return undefined // Segments will be split across videos
    return videoScope // Specific video ID
  }

  // Generation mode: 'manual' = define segments yourself, 'auto' = AI decides segments
  const [mode, setMode] = useState<GenerationMode>('auto')

  // Confirmation dialog for overriding existing segments
  const [showOverrideConfirm, setShowOverrideConfirm] = useState(false)
  const [pendingAction, setPendingAction] = useState<'auto' | 'apply' | null>(null)

  // Provider state
  const [provider, setProvider] = useState<ProviderType>('ollama')
  const [model, setModel] = useState('')
  const [apiKey, setApiKey] = useState('')
  const [customEndpoint, setCustomEndpoint] = useState('')

  // Style settings
  const [tone, setTone] = useState('documentary')
  const [style, setStyle] = useState('narrative')
  const [audience, setAudience] = useState('general')
  const [language, setLanguage] = useState('en')

  // Auto mode settings
  const [videoDescription, setVideoDescription] = useState('')
  const [videoTitle, setVideoTitle] = useState('')
  const [minSegmentDuration, setMinSegmentDuration] = useState(5)
  const [maxSegmentDuration, setMaxSegmentDuration] = useState(30)

  // Segment inputs (for manual mode)
  const [segmentInputs, setSegmentInputs] = useState<SegmentInput[]>([
    { id: '1', startTime: 0, endTime: Math.min(15, videoDuration), description: '' },
  ])

  // Generated scripts
  const [generatedScripts, setGeneratedScripts] = useState<GeneratedScript[]>([])
  const [autoGeneratedSegments, setAutoGeneratedSegments] = useState<AutoGeneratedSegment[]>([])
  const [showAdvanced, setShowAdvanced] = useState(false)

  // Generation progress state
  const [generationProgress, setGenerationProgress] = useState<{
    stage: string
    message: string
    progress: number
    detail?: string
    segmentCount: number
    segmentsValidated: number
    segmentsRefined: number
    refinementAttempt: number
    maxRefinements: number
  } | null>(null)

  // Check if there are existing segments
  const hasExistingSegments = existingSegments.length > 0

  // Calculate timeline coverage for mini timeline
  const timelineMarkers = useMemo(() => {
    const duration = effectiveDuration
    const interval = duration > 300 ? 60 : duration > 60 ? 10 : 5
    const count = Math.floor(duration / interval)
    return Array.from({ length: count + 1 }, (_, i) => i * interval)
  }, [effectiveDuration])

  // Initialize manual mode with existing segments when switching modes
  useEffect(() => {
    if (mode === 'manual' && hasExistingSegments && segmentInputs.length === 1 && !segmentInputs[0].description) {
      // Load existing segments into manual mode
      const loadedSegments = existingSegments.map((seg) => ({
        id: seg.id,
        startTime: seg.start_time,
        endTime: seg.end_time,
        description: seg.text || '',
      }))
      setSegmentInputs(loadedSegments)
    }
  }, [mode, hasExistingSegments, existingSegments])

  // Fetch Ollama models
  const { data: ollamaData } = useQuery({
    queryKey: ['ollama-models'],
    queryFn: () => llmApi.listOllamaModels(),
    enabled: provider === 'ollama',
  })

  const ollamaModels: OllamaModel[] = ollamaData?.data?.models || []
  const ollamaConnected = ollamaData?.data?.connected ?? false

  // Fetch vision models availability
  const { data: visionData } = useQuery({
    queryKey: ['vision-models'],
    queryFn: () => llmApi.checkVisionModels(),
    enabled: provider === 'ollama',
  })

  const visionModelsAvailable = visionData?.data?.available ?? false
  const visionModels = visionData?.data?.vision_models || []
  const visionInstallCommand = visionData?.data?.install_command
  const visionMessage = visionData?.data?.message

  // Get effective video path based on scope
  const getEffectiveVideoPath = useMemo(() => {
    if (videoScope === 'current') {
      const currentVideo = videos.find(v => v.id === videoId)
      return currentVideo?.path || videoPath
    }
    // For all videos or specific video, get the first/selected video path
    const targetVideos = getTargetVideos
    return targetVideos[0]?.path || videoPath
  }, [videoScope, videoId, videos, videoPath, getTargetVideos])

  // Set model to first available when models load or provider changes
  useEffect(() => {
    if (provider === 'ollama') {
      if (ollamaModels.length > 0) {
        setModel(ollamaModels[0].name)
      }
    } else if (provider === 'openai') {
      setModel('gpt-4-turbo-preview')
    } else if (provider === 'anthropic') {
      setModel('claude-3-opus-20240229')
    } else if (provider === 'custom') {
      setModel('default')
    }
  }, [provider, ollamaModels])

  // Add segment
  const addSegment = () => {
    const lastSegment = segmentInputs[segmentInputs.length - 1]
    const newStart = lastSegment ? lastSegment.endTime : 0
    const newEnd = Math.min(newStart + 15, videoDuration)

    if (newStart >= videoDuration) {
      toast.error('Cannot add more segments - video duration reached')
      return
    }

    setSegmentInputs([
      ...segmentInputs,
      {
        id: Date.now().toString(),
        startTime: newStart,
        endTime: newEnd,
        description: '',
      },
    ])
  }

  // Remove segment
  const removeSegment = (id: string) => {
    if (segmentInputs.length === 1) return
    setSegmentInputs(segmentInputs.filter((s) => s.id !== id))
  }

  // Update segment
  const updateSegment = (id: string, field: keyof SegmentInput, value: string | number) => {
    setSegmentInputs(
      segmentInputs.map((s) => (s.id === id ? { ...s, [field]: value } : s))
    )
  }

  // Update auto-generated segment (make editable)
  const updateAutoSegment = (index: number, field: keyof AutoGeneratedSegment, value: string | number) => {
    setAutoGeneratedSegments(
      autoGeneratedSegments.map((s, i) => (i === index ? { ...s, [field]: value } : s))
    )
  }

  // Remove auto-generated segment
  const removeAutoSegment = (index: number) => {
    setAutoGeneratedSegments(autoGeneratedSegments.filter((_, i) => i !== index))
  }

  // Handle action with override check
  const handleActionWithOverrideCheck = (action: 'auto' | 'apply') => {
    if (hasExistingSegments) {
      setPendingAction(action)
      setShowOverrideConfirm(true)
    } else {
      executeAction(action)
    }
  }

  // Execute the pending action
  const executeAction = (action: 'auto' | 'apply') => {
    if (action === 'auto') {
      autoSegmentMutation.mutate()
    } else if (action === 'apply') {
      applyMutation.mutate()
    }
    setShowOverrideConfirm(false)
    setPendingAction(null)
  }

  // Format time helper
  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  // Generate mutation (manual mode)
  const generateMutation = useMutation({
    mutationFn: async () => {
      const segments: SegmentDescription[] = segmentInputs.map((s) => ({
        start_time: s.startTime,
        end_time: s.endTime,
        description: s.description,
      }))

      const providerConfig = {
        type: provider,
        model,
        api_key: apiKey || undefined,
        endpoint: provider === 'custom' ? customEndpoint : undefined,
      }

      const response = await llmApi.generateScript({
        provider: providerConfig,
        segments,
        style: { tone, style, audience, length: 'moderate', language },
        fit_to_duration: true,
      })

      return response.data
    },
    onMutate: () => {
      setIsGeneratingScript(true)
    },
    onSuccess: (data) => {
      setGeneratedScripts(data.scripts)
      setIsGeneratingScript(false)

      if (data.all_fit) {
        toast.success('Scripts generated successfully!')
      } else {
        toast('Some scripts may not fit their segments', { icon: '⚠️' })
      }
    },
    onError: (error: Error) => {
      setIsGeneratingScript(false)
      toast.error(error.message || 'Failed to generate scripts')
    },
  })

  // Auto-segment mutation (auto mode) - now using intelligent endpoint with video analysis
  const autoSegmentMutation = useMutation({
    mutationFn: async () => {
      const providerConfig = {
        type: provider,
        model,
        api_key: apiKey || undefined,
        endpoint: provider === 'custom' ? customEndpoint : undefined,
      }

      // Use the new intelligent endpoint with optional video analysis
      const response = await llmApi.intelligentAutoSegment({
        provider: providerConfig,
        video_duration: effectiveDuration,
        video_description: videoDescription,
        video_title: videoTitle || undefined,
        style: { tone, style, audience, length: 'moderate', language },
        min_segment_duration: minSegmentDuration,
        max_segment_duration: maxSegmentDuration,
        max_refinement_iterations: 3,
        stream: false, // Using non-streaming for now
        // Video analysis options
        video_path: useVideoAnalysis ? getEffectiveVideoPath : undefined,
        vision_model: useVideoAnalysis ? visionModel : undefined,
        use_video_analysis: useVideoAnalysis && !!getEffectiveVideoPath,
      })

      return response.data
    },
    onMutate: () => {
      setIsGeneratingScript(true)
      setGenerationProgress({
        stage: 'initializing',
        message: 'Starting intelligent script generation...',
        progress: 5,
        segmentCount: 0,
        segmentsValidated: 0,
        segmentsRefined: 0,
        refinementAttempt: 0,
        maxRefinements: 3,
      })
    },
    onSuccess: (data) => {
      // Transform response to match expected format
      const segments = data.segments.map((seg: Record<string, unknown>) => ({
        segment_index: seg.segment_index,
        name: seg.name,
        start_time: seg.start_time,
        end_time: seg.end_time,
        description: seg.description,
        script: seg.script,
        estimated_duration: seg.estimated_duration,
        word_count: seg.word_count,
        fits_duration: seg.fits_duration,
      }))

      setAutoGeneratedSegments(segments)
      setIsGeneratingScript(false)
      setGenerationProgress(null)

      const allFit = data.all_fit
      const totalSegments = data.total_segments
      const coverage = data.coverage_percent

      if (allFit) {
        toast.success(`${totalSegments} segments generated (${coverage?.toFixed(0) || 0}% coverage)`)
      } else {
        toast(`${totalSegments} segments generated with timing adjustments`, { icon: '⚠️' })
      }

      // Show refinement info if any
      if (data.refinement_iterations > 0) {
        toast.success(`${data.refinement_iterations} segment(s) refined for better fit`)
      }

      if (data.warnings && data.warnings.length > 0) {
        data.warnings.slice(0, 3).forEach((w: string) => toast(w, { icon: '⚠️' }))
      }
    },
    onError: (error: Error) => {
      setIsGeneratingScript(false)
      setGenerationProgress(null)
      toast.error(error.message || 'Failed to auto-generate segments')
    },
  })

  // Apply scripts mutation (works for both modes)
  const applyMutation = useMutation({
    mutationFn: async () => {
      let segments

      if (mode === 'auto' && autoGeneratedSegments.length > 0) {
        // Auto mode: use auto-generated segments with their names and scripts
        segments = autoGeneratedSegments.map((seg) => ({
          name: seg.name,
          start_time: seg.start_time,
          end_time: seg.end_time,
          text: seg.script,
          language,
        }))
      } else {
        // Manual mode: use generated scripts
        segments = generatedScripts.map((script, i) => ({
          name: `Segment ${i + 1}`,
          start_time: script.start_time,
          end_time: script.end_time,
          text: script.text,
          language,
        }))
      }

      const response = await segmentsApi.createBatch(projectName, segments, getEffectiveVideoId())
      return response.data
    },
    onSuccess: (data) => {
      setSegments(data.segments)
      // Invalidate the segments query to ensure ProjectPage gets fresh data
      queryClient.invalidateQueries({ queryKey: ['segments', projectName] })
      toast.success(`${data.created} segments created!`)
      onClose()
    },
    onError: (error: unknown) => {
      const axiosError = error as { response?: { data?: { detail?: string; errors?: Array<{ index: number; error: string }> } } }
      // Check for individual segment errors in batch response
      const errors = axiosError?.response?.data?.errors
      if (errors && errors.length > 0) {
        // Show the first error message with context
        const firstError = errors[0]
        toast.error(`Segment ${firstError.index + 1} failed: ${firstError.error}`)
      } else {
        // Fallback to detail or generic message
        const errorMessage = axiosError?.response?.data?.detail || 'Failed to apply scripts'
        toast.error(errorMessage)
      }
    },
  })

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" onClick={onClose} />

      {/* Override Confirmation Dialog */}
      <AnimatePresence>
        {showOverrideConfirm && (
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            className="absolute z-50 bg-terminal-surface border border-yellow-500/50 rounded-lg p-4 max-w-md mx-4 shadow-lg"
          >
            <div className="flex items-start gap-3 mb-4">
              <div className="w-10 h-10 rounded-lg bg-yellow-500/20 flex items-center justify-center shrink-0">
                <AlertTriangle className="w-5 h-5 text-yellow-500" />
              </div>
              <div>
                <h3 className="font-semibold text-yellow-500">Replace Existing Segments?</h3>
                <p className="text-sm text-text-muted mt-1">
                  You have {existingSegments.length} existing segment{existingSegments.length !== 1 ? 's' : ''} on the timeline.
                  This action will replace all existing segments with the new ones.
                </p>
              </div>
            </div>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setShowOverrideConfirm(false)
                  setPendingAction(null)
                }}
                className="btn-secondary text-sm"
              >
                Cancel
              </button>
              <button
                onClick={() => pendingAction && executeAction(pendingAction)}
                className="btn-primary bg-yellow-600 hover:bg-yellow-700 text-sm"
              >
                Yes, Replace
              </button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      <motion.div
        initial={{ opacity: 0, scale: 0.95, y: 20 }}
        animate={{ opacity: 1, scale: 1, y: 0 }}
        exit={{ opacity: 0, scale: 0.95, y: 20 }}
        className="relative bg-terminal-surface border border-terminal-border rounded-lg w-full max-w-4xl mx-4 max-h-[90vh] flex flex-col overflow-hidden"
      >
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-terminal-border bg-terminal-bg/50">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-lg bg-accent-red/20 flex items-center justify-center border border-accent-red/30">
              <Sparkles className="w-5 h-5 text-accent-red" />
            </div>
            <div>
              <h2 className="font-semibold">AI Script Generator</h2>
              <p className="text-xs text-text-muted">Generate narration scripts with AI</p>
            </div>
          </div>
          <button onClick={onClose} className="p-2 rounded hover:bg-terminal-elevated text-text-muted">
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4 space-y-6">
          {/* Mode Selection */}
          <div className="grid grid-cols-2 gap-2">
            <button
              onClick={() => {
                setMode('auto')
                setGeneratedScripts([])
              }}
              className={clsx(
                'p-3 rounded-lg border text-sm transition-all text-left',
                mode === 'auto'
                  ? 'bg-accent-red/20 border-accent-red'
                  : 'bg-terminal-elevated border-terminal-border hover:border-accent-red/50'
              )}
            >
              <div className="flex items-center gap-2">
                <Film className={clsx('w-5 h-5', mode === 'auto' ? 'text-accent-red' : 'text-text-muted')} />
                <div>
                  <div className={clsx('font-medium', mode === 'auto' ? 'text-accent-red' : 'text-text-primary')}>
                    Auto-Generate Segments
                  </div>
                  <div className="text-[10px] text-text-muted mt-0.5">
                    Describe video, AI creates segments & scripts
                  </div>
                </div>
              </div>
            </button>
            <button
              onClick={() => {
                setMode('manual')
                setAutoGeneratedSegments([])
              }}
              className={clsx(
                'p-3 rounded-lg border text-sm transition-all text-left',
                mode === 'manual'
                  ? 'bg-accent-red/20 border-accent-red'
                  : 'bg-terminal-elevated border-terminal-border hover:border-accent-red/50'
              )}
            >
              <div className="flex items-center gap-2">
                <LayoutGrid className={clsx('w-5 h-5', mode === 'manual' ? 'text-accent-red' : 'text-text-muted')} />
                <div>
                  <div className={clsx('font-medium', mode === 'manual' ? 'text-accent-red' : 'text-text-primary')}>
                    Define Segments Manually
                  </div>
                  <div className="text-[10px] text-text-muted mt-0.5">
                    Set timing yourself, AI writes scripts
                  </div>
                </div>
              </div>
            </button>
          </div>

          {/* Video Scope Selector (only show when multiple videos) */}
          {hasMultipleVideos && (
            <div className="console-card p-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Film className="w-4 h-4 text-text-muted" />
                  <span className="text-sm text-text-secondary">Generate scripts for:</span>
                </div>
                <select
                  value={videoScope}
                  onChange={(e) => setVideoScope(e.target.value as VideoScope)}
                  className="input-base py-1 px-2 text-sm min-w-[150px]"
                >
                  <option value="current">Current Video</option>
                  <option value="all">All Videos ({videos.length})</option>
                  {videos.map((v) => (
                    <option key={v.id} value={v.id} disabled={!v.file_exists}>
                      {v.name} ({formatTime(v.duration || 0)})
                      {!v.file_exists && ' (missing)'}
                    </option>
                  ))}
                </select>
              </div>
              {videoScope === 'all' && (
                <p className="text-xs text-text-muted mt-2">
                  Total duration: {formatTime(effectiveDuration)} across {getTargetVideos.length} video{getTargetVideos.length !== 1 ? 's' : ''}
                </p>
              )}
            </div>
          )}

          {/* Mini Timeline - Show existing segments */}
          <div className="console-card p-3">
            <div className="flex items-center justify-between mb-2">
              <span className="text-xs text-text-muted">
                Timeline: {formatTime(effectiveDuration)} ({existingSegments.length} existing segment{existingSegments.length !== 1 ? 's' : ''})
              </span>
              {hasExistingSegments && (
                <span className="text-xs text-yellow-500 flex items-center gap-1">
                  <AlertTriangle className="w-3 h-3" />
                  New segments will replace existing
                </span>
              )}
            </div>

            {/* Mini timeline track */}
            <div className="relative h-8 bg-terminal-bg rounded border border-terminal-border">
              {/* Time markers */}
              {timelineMarkers.map((time) => (
                <div
                  key={time}
                  className="absolute top-0 bottom-0 w-px bg-terminal-border/50"
                  style={{ left: `${(time / effectiveDuration) * 100}%` }}
                />
              ))}

              {/* Existing segments */}
              {existingSegments.map((seg) => (
                <div
                  key={seg.id}
                  className="absolute top-1 bottom-1 bg-accent-red/30 border border-accent-red/50 rounded"
                  style={{
                    left: `${(seg.start_time / effectiveDuration) * 100}%`,
                    width: `${((seg.end_time - seg.start_time) / effectiveDuration) * 100}%`,
                    minWidth: '4px',
                  }}
                  title={`${seg.name}: ${seg.start_time.toFixed(1)}s - ${seg.end_time.toFixed(1)}s`}
                />
              ))}

              {/* Auto-generated segments preview (overlay in different color) */}
              {autoGeneratedSegments.map((seg, i) => (
                <div
                  key={`auto-${i}`}
                  className="absolute top-1 bottom-1 bg-green-500/30 border border-green-500/50 rounded"
                  style={{
                    left: `${(seg.start_time / effectiveDuration) * 100}%`,
                    width: `${((seg.end_time - seg.start_time) / effectiveDuration) * 100}%`,
                    minWidth: '4px',
                  }}
                  title={`${seg.name}: ${seg.start_time.toFixed(1)}s - ${seg.end_time.toFixed(1)}s`}
                />
              ))}

              {/* Empty state */}
              {existingSegments.length === 0 && autoGeneratedSegments.length === 0 && (
                <div className="absolute inset-0 flex items-center justify-center text-text-muted text-[10px]">
                  No segments defined yet
                </div>
              )}
            </div>

            {/* Legend */}
            <div className="flex items-center gap-4 mt-2 text-[10px] text-text-muted">
              {hasExistingSegments && (
                <div className="flex items-center gap-1">
                  <div className="w-3 h-2 bg-accent-red/30 border border-accent-red/50 rounded" />
                  <span>Existing</span>
                </div>
              )}
              {autoGeneratedSegments.length > 0 && (
                <div className="flex items-center gap-1">
                  <div className="w-3 h-2 bg-green-500/30 border border-green-500/50 rounded" />
                  <span>Generated (preview)</span>
                </div>
              )}
            </div>
          </div>

          {/* Provider Selection */}
          <div className="grid grid-cols-2 lg:grid-cols-4 gap-2">
            {(['ollama', 'openai', 'anthropic', 'custom'] as ProviderType[]).map((p) => (
              <button
                key={p}
                onClick={() => setProvider(p)}
                className={clsx(
                  'p-3 rounded-lg border text-sm transition-all',
                  provider === p
                    ? 'bg-accent-red/20 border-accent-red text-accent-red'
                    : 'bg-terminal-elevated border-terminal-border text-text-secondary hover:border-accent-red/50'
                )}
              >
                <div className="font-medium capitalize">{p}</div>
                <div className="text-[10px] text-text-muted mt-0.5">
                  {p === 'ollama' && 'Local AI'}
                  {p === 'openai' && 'GPT-4'}
                  {p === 'anthropic' && 'Claude'}
                  {p === 'custom' && 'Custom API'}
                </div>
              </button>
            ))}
          </div>

          {/* Provider-specific settings */}
          <div className="console-card p-4">
            {provider === 'ollama' && (
              <div>
                <label className="section-header">Ollama Model</label>
                {!ollamaConnected ? (
                  <div className="flex items-center gap-2 text-yellow-500 text-sm">
                    <AlertTriangle className="w-4 h-4" />
                    <span>Ollama not running. Start with: <code className="bg-terminal-bg px-1 rounded">ollama serve</code></span>
                  </div>
                ) : (
                  <select
                    value={model}
                    onChange={(e) => setModel(e.target.value)}
                    className="input-base w-full"
                  >
                    {ollamaModels.map((m) => (
                      <option key={m.name} value={m.name}>
                        {m.name} ({m.size})
                      </option>
                    ))}
                  </select>
                )}
              </div>
            )}

            {(provider === 'openai' || provider === 'anthropic') && (
              <div className="space-y-3">
                <div>
                  <label className="section-header">API Key</label>
                  <input
                    type="password"
                    value={apiKey}
                    onChange={(e) => setApiKey(e.target.value)}
                    placeholder={`Enter your ${provider} API key`}
                    className="input-base w-full font-mono"
                  />
                </div>
                <div>
                  <label className="section-header">Model</label>
                  <select
                    value={model}
                    onChange={(e) => setModel(e.target.value)}
                    className="input-base w-full"
                  >
                    {provider === 'openai' && (
                      <>
                        <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                        <option value="gpt-4">GPT-4</option>
                        <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                      </>
                    )}
                    {provider === 'anthropic' && (
                      <>
                        <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                        <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
                        <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                      </>
                    )}
                  </select>
                </div>
              </div>
            )}

            {provider === 'custom' && (
              <div className="space-y-3">
                <div>
                  <label className="section-header">Endpoint URL</label>
                  <input
                    type="text"
                    value={customEndpoint}
                    onChange={(e) => setCustomEndpoint(e.target.value)}
                    placeholder="https://your-api.com/v1"
                    className="input-base w-full font-mono"
                  />
                </div>
                <div>
                  <label className="section-header">API Key (optional)</label>
                  <input
                    type="password"
                    value={apiKey}
                    onChange={(e) => setApiKey(e.target.value)}
                    placeholder="API key if required"
                    className="input-base w-full font-mono"
                  />
                </div>
              </div>
            )}
          </div>

          {/* Style Settings */}
          <div>
            <button
              onClick={() => setShowAdvanced(!showAdvanced)}
              className="flex items-center gap-2 text-sm text-text-muted hover:text-text-primary mb-3"
            >
              <Settings className="w-4 h-4" />
              <span>Style Settings</span>
              <ChevronDown className={clsx('w-4 h-4 transition-transform', showAdvanced && 'rotate-180')} />
            </button>

            <AnimatePresence>
              {showAdvanced && (
                <motion.div
                  initial={{ height: 0, opacity: 0 }}
                  animate={{ height: 'auto', opacity: 1 }}
                  exit={{ height: 0, opacity: 0 }}
                  className="overflow-hidden"
                >
                  <div className="grid grid-cols-2 lg:grid-cols-4 gap-3 console-card p-4">
                    <div>
                      <label className="section-header">Tone</label>
                      <select value={tone} onChange={(e) => setTone(e.target.value)} className="input-base w-full">
                        <option value="documentary">Documentary</option>
                        <option value="professional">Professional</option>
                        <option value="casual">Casual</option>
                        <option value="dramatic">Dramatic</option>
                        <option value="educational">Educational</option>
                      </select>
                    </div>
                    <div>
                      <label className="section-header">Style</label>
                      <select value={style} onChange={(e) => setStyle(e.target.value)} className="input-base w-full">
                        <option value="narrative">Narrative</option>
                        <option value="conversational">Conversational</option>
                        <option value="instructional">Instructional</option>
                        <option value="storytelling">Storytelling</option>
                      </select>
                    </div>
                    <div>
                      <label className="section-header">Audience</label>
                      <select value={audience} onChange={(e) => setAudience(e.target.value)} className="input-base w-full">
                        <option value="general">General</option>
                        <option value="technical">Technical</option>
                        <option value="children">Children</option>
                        <option value="business">Business</option>
                      </select>
                    </div>
                    <div>
                      <label className="section-header">Language</label>
                      <select value={language} onChange={(e) => setLanguage(e.target.value)} className="input-base w-full">
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="hi">Hindi</option>
                      </select>
                    </div>
                  </div>
                </motion.div>
              )}
            </AnimatePresence>
          </div>

          {/* Auto Mode: Video Description */}
          {mode === 'auto' && (
            <div className="space-y-4">
              {/* AI Video Analysis Section */}
              {provider === 'ollama' && (
                <div className={clsx(
                  'console-card p-4 border-l-4',
                  visionModelsAvailable ? 'border-l-green-500' : 'border-l-yellow-500'
                )}>
                  <div className="flex items-start justify-between">
                    <div className="flex items-start gap-3">
                      <div className={clsx(
                        'w-10 h-10 rounded-lg flex items-center justify-center',
                        visionModelsAvailable ? 'bg-green-500/20' : 'bg-yellow-500/20'
                      )}>
                        <Eye className={clsx(
                          'w-5 h-5',
                          visionModelsAvailable ? 'text-green-500' : 'text-yellow-500'
                        )} />
                      </div>
                      <div>
                        <h4 className="font-medium text-sm flex items-center gap-2">
                          AI Video Analysis
                          <span className="text-[10px] px-1.5 py-0.5 rounded bg-accent-red/20 text-accent-red">
                            Experimental
                          </span>
                        </h4>
                        <p className="text-xs text-text-muted mt-0.5">
                          {visionModelsAvailable
                            ? 'Let AI watch and understand your video content automatically'
                            : 'Install a vision model to enable AI video understanding'}
                        </p>
                      </div>
                    </div>
                    {visionModelsAvailable && getEffectiveVideoPath && (
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={useVideoAnalysis}
                          onChange={(e) => setUseVideoAnalysis(e.target.checked)}
                          className="w-4 h-4 rounded border-terminal-border bg-terminal-bg text-accent-red focus:ring-accent-red"
                        />
                        <span className="text-sm">Enable</span>
                      </label>
                    )}
                  </div>

                  {/* Vision Model Not Available - Install Instructions */}
                  {!visionModelsAvailable && visionInstallCommand && (
                    <div className="mt-3 p-3 bg-terminal-bg rounded-lg">
                      <p className="text-xs text-text-muted mb-2">{visionMessage}</p>
                      <div className="flex items-center gap-2">
                        <code className="flex-1 text-xs bg-terminal-elevated px-2 py-1.5 rounded font-mono text-accent-red">
                          {visionInstallCommand}
                        </code>
                        <button
                          onClick={() => {
                            navigator.clipboard.writeText(visionInstallCommand)
                            toast.success('Command copied!')
                          }}
                          className="btn-secondary text-xs py-1 px-2"
                        >
                          Copy
                        </button>
                      </div>
                      <p className="text-[10px] text-text-muted mt-2">
                        Run this command in your terminal, then refresh this page.
                      </p>
                    </div>
                  )}

                  {/* Vision Model Available - Options */}
                  {visionModelsAvailable && useVideoAnalysis && (
                    <div className="mt-3 space-y-3">
                      <div className="flex items-center gap-3">
                        <div className="flex-1">
                          <label className="text-xs text-text-muted">Vision Model</label>
                          <select
                            value={visionModel}
                            onChange={(e) => setVisionModel(e.target.value)}
                            className="input-base w-full text-sm mt-1"
                          >
                            {visionModels.map((m: { name: string; size: string }) => (
                              <option key={m.name} value={m.name}>
                                {m.name} ({m.size})
                              </option>
                            ))}
                          </select>
                        </div>
                        <div className="text-xs text-text-muted">
                          <Video className="w-4 h-4 inline mr-1" />
                          {getEffectiveVideoPath ? 'Video ready' : 'No video path'}
                        </div>
                      </div>
                      <p className="text-xs text-text-muted bg-terminal-bg p-2 rounded">
                        <strong>How it works:</strong> AI will extract frames from your video, analyze the visual content, and use this understanding to generate more accurate and contextual scripts. This adds ~30-60s to generation time.
                      </p>
                    </div>
                  )}

                  {/* No Video Path Warning */}
                  {visionModelsAvailable && !getEffectiveVideoPath && (
                    <div className="mt-3 flex items-center gap-2 text-xs text-yellow-500">
                      <AlertTriangle className="w-4 h-4" />
                      <span>Video path not available. Video analysis requires access to the video file.</span>
                    </div>
                  )}
                </div>
              )}

              <div className="console-card p-4 space-y-4">
                <div>
                  <label className="section-header">Video Title (optional)</label>
                  <input
                    type="text"
                    value={videoTitle}
                    onChange={(e) => setVideoTitle(e.target.value)}
                    placeholder="e.g., Product Demo, Travel Vlog, Tutorial..."
                    className="input-base w-full"
                  />
                </div>
                <div>
                  <label className="section-header">
                    Video Description <span className="text-accent-red">*</span>
                    {useVideoAnalysis && (
                      <span className="text-xs text-green-500 ml-2 font-normal">
                        + AI will enhance with video analysis
                      </span>
                    )}
                  </label>
                  <textarea
                    value={videoDescription}
                    onChange={(e) => setVideoDescription(e.target.value)}
                    placeholder={useVideoAnalysis
                      ? "Provide a brief description or context. AI will analyze the video to understand the visual content automatically..."
                      : "Describe what happens in your video from start to finish. Be specific about key moments, transitions, and what should be narrated. The AI will use this to create optimal segment breakdowns with scripts..."
                    }
                    rows={useVideoAnalysis ? 3 : 5}
                    className="input-base w-full text-sm resize-none"
                  />
                  <p className="text-xs text-text-muted mt-1">
                    Video duration: {effectiveDuration.toFixed(1)}s ({(effectiveDuration / 60).toFixed(1)} min)
                  </p>
                </div>
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">Min Segment Duration</label>
                    <div className="flex items-center gap-2">
                      <input
                        type="number"
                        min="3"
                        max={maxSegmentDuration}
                        value={minSegmentDuration}
                        onChange={(e) => setMinSegmentDuration(Number(e.target.value))}
                        className="input-base w-20 font-mono"
                      />
                      <span className="text-xs text-text-muted">seconds</span>
                    </div>
                  </div>
                  <div>
                    <label className="section-header">Max Segment Duration</label>
                    <div className="flex items-center gap-2">
                      <input
                        type="number"
                        min={minSegmentDuration}
                        max="120"
                        value={maxSegmentDuration}
                        onChange={(e) => setMaxSegmentDuration(Number(e.target.value))}
                        className="input-base w-20 font-mono"
                      />
                      <span className="text-xs text-text-muted">seconds</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Manual Mode: Segment Descriptions */}
          {mode === 'manual' && (
            <div>
              <div className="flex items-center justify-between mb-3">
                <label className="section-header mb-0">Segment Descriptions</label>
                <button onClick={addSegment} className="btn-secondary text-xs py-1 px-2">
                  + Add Segment
                </button>
              </div>

              <div className="space-y-3">
                {segmentInputs.map((seg, i) => (
                  <motion.div
                    key={seg.id}
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="console-card p-3"
                  >
                    <div className="flex items-start gap-3">
                      <div className="w-8 h-8 rounded bg-accent-red/20 flex items-center justify-center text-accent-red font-mono text-sm shrink-0">
                        {i + 1}
                      </div>
                      <div className="flex-1 space-y-2">
                        <div className="flex gap-2">
                          <div className="flex-1">
                            <div className="flex items-center gap-2 text-xs text-text-muted mb-1">
                              <Clock className="w-3 h-3" />
                              <input
                                type="number"
                                step="0.5"
                                min="0"
                                value={seg.startTime}
                                onChange={(e) => updateSegment(seg.id, 'startTime', parseFloat(e.target.value))}
                                className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                              />
                              <span>→</span>
                              <input
                                type="number"
                                step="0.5"
                                min="0"
                                value={seg.endTime}
                                onChange={(e) => updateSegment(seg.id, 'endTime', parseFloat(e.target.value))}
                                className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                              />
                              <span className="text-text-disabled">({(seg.endTime - seg.startTime).toFixed(1)}s)</span>
                            </div>
                          </div>
                          {segmentInputs.length > 1 && (
                            <button
                              onClick={() => removeSegment(seg.id)}
                              className="p-1 text-text-muted hover:text-accent-red"
                            >
                              <X className="w-4 h-4" />
                            </button>
                          )}
                        </div>
                        <textarea
                          value={seg.description}
                          onChange={(e) => updateSegment(seg.id, 'description', e.target.value)}
                          placeholder="Describe what happens in this segment..."
                          rows={2}
                          className="input-base w-full text-sm resize-none"
                        />
                      </div>
                    </div>
                  </motion.div>
                ))}
              </div>
            </div>
          )}

          {/* Generation Progress Panel */}
          {isGeneratingScript && generationProgress && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="console-card p-4 border-l-4 border-l-accent-red"
            >
              <div className="flex items-center gap-3 mb-3">
                <Loader2 className="w-5 h-5 text-accent-red animate-spin" />
                <div className="flex-1">
                  <h4 className="font-medium text-sm">{generationProgress.message}</h4>
                  {generationProgress.detail && (
                    <p className="text-xs text-text-muted mt-0.5">{generationProgress.detail}</p>
                  )}
                </div>
                <span className="text-xs text-text-muted font-mono">
                  {generationProgress.progress}%
                </span>
              </div>

              {/* Progress bar */}
              <div className="h-2 bg-terminal-bg rounded-full overflow-hidden mb-3">
                <motion.div
                  className="h-full bg-accent-red"
                  initial={{ width: 0 }}
                  animate={{ width: `${generationProgress.progress}%` }}
                  transition={{ duration: 0.3 }}
                />
              </div>

              {/* Stage indicators */}
              <div className="flex items-center gap-4 text-xs text-text-muted">
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'analyzing_video' || generationProgress.stage === 'crafting_prompt'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 15 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Analyze</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'generating'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 50 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Generate</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'validating'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 65 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Validate</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'refining'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 90 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Refine</span>
                </div>
              </div>

              {/* Refinement info */}
              {generationProgress.stage === 'refining' && generationProgress.refinementAttempt > 0 && (
                <div className="mt-2 text-xs text-yellow-500 flex items-center gap-1">
                  <RefreshCw className="w-3 h-3" />
                  <span>
                    Refinement pass {generationProgress.refinementAttempt}/{generationProgress.maxRefinements}
                  </span>
                </div>
              )}
            </motion.div>
          )}

          {/* Auto-Generated Segments (Auto Mode) - Editable */}
          {mode === 'auto' && autoGeneratedSegments.length > 0 && (
            <div>
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <FileText className="w-4 h-4 text-accent-red" />
                  <label className="section-header mb-0">Generated Segments & Scripts</label>
                  <span className="text-xs text-text-muted">(editable)</span>
                </div>
                <button
                  onClick={() => {
                    const lastSeg = autoGeneratedSegments[autoGeneratedSegments.length - 1]
                    const newStart = lastSeg ? lastSeg.end_time : 0
                    const newEnd = Math.min(newStart + 15, videoDuration)
                    if (newStart < videoDuration) {
                      setAutoGeneratedSegments([
                        ...autoGeneratedSegments,
                        {
                          segment_index: autoGeneratedSegments.length,
                          name: `Segment ${autoGeneratedSegments.length + 1}`,
                          start_time: newStart,
                          end_time: newEnd,
                          description: '',
                          script: '',
                          word_count: 0,
                          estimated_duration: 0,
                          fits_duration: true,
                        },
                      ])
                    }
                  }}
                  className="btn-secondary text-xs py-1 px-2 flex items-center gap-1"
                >
                  <Plus className="w-3 h-3" />
                  Add Segment
                </button>
              </div>

              <div className="space-y-3">
                {autoGeneratedSegments.map((seg, i) => (
                  <motion.div
                    key={i}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: i * 0.05 }}
                    className={clsx(
                      'console-card p-3 border-l-4',
                      seg.fits_duration ? 'border-l-green-500' : 'border-l-yellow-500'
                    )}
                  >
                    {/* Header row with name and timing inputs */}
                    <div className="flex items-start gap-3 mb-3">
                      <div className="w-8 h-8 rounded bg-green-500/20 flex items-center justify-center text-green-500 font-mono text-sm shrink-0">
                        {i + 1}
                      </div>
                      <div className="flex-1">
                        <div className="flex items-center gap-3 flex-wrap">
                          {/* Segment name */}
                          <input
                            type="text"
                            value={seg.name}
                            onChange={(e) => updateAutoSegment(i, 'name', e.target.value)}
                            className="input-base py-1 px-2 text-sm font-medium w-40"
                            placeholder="Segment name"
                          />
                          {/* Timing controls */}
                          <div className="flex items-center gap-2 text-xs text-text-muted">
                            <Clock className="w-3 h-3" />
                            <input
                              type="number"
                              step="0.5"
                              min="0"
                              max={videoDuration}
                              value={seg.start_time}
                              onChange={(e) => updateAutoSegment(i, 'start_time', parseFloat(e.target.value) || 0)}
                              className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                            />
                            <span>→</span>
                            <input
                              type="number"
                              step="0.5"
                              min="0"
                              max={videoDuration}
                              value={seg.end_time}
                              onChange={(e) => updateAutoSegment(i, 'end_time', parseFloat(e.target.value) || 0)}
                              className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                            />
                            <span className="text-text-disabled">({(seg.end_time - seg.start_time).toFixed(1)}s)</span>
                          </div>
                          {/* Stats */}
                          <div className="flex items-center gap-2 text-xs text-text-muted ml-auto">
                            <span>{seg.word_count} words</span>
                            <span>~{seg.estimated_duration.toFixed(1)}s</span>
                            {seg.fits_duration ? (
                              <Check className="w-4 h-4 text-green-500" />
                            ) : (
                              <span title="Script may not fit duration">
                              <AlertTriangle className="w-4 h-4 text-yellow-500" />
                            </span>
                            )}
                          </div>
                          {/* Delete button */}
                          {autoGeneratedSegments.length > 1 && (
                            <button
                              onClick={() => removeAutoSegment(i)}
                              className="p-1 text-text-muted hover:text-accent-red transition-colors"
                              title="Remove segment"
                            >
                              <Trash2 className="w-4 h-4" />
                            </button>
                          )}
                        </div>
                      </div>
                    </div>

                    {/* Script textarea - editable */}
                    <div className="ml-11">
                      <textarea
                        value={seg.script}
                        onChange={(e) => {
                          const newScript = e.target.value
                          const wordCount = newScript.trim().split(/\s+/).filter(Boolean).length
                          const estimatedDuration = wordCount / 2.5 // ~150 words per minute
                          setAutoGeneratedSegments(
                            autoGeneratedSegments.map((s, idx) =>
                              idx === i
                                ? {
                                    ...s,
                                    script: newScript,
                                    word_count: wordCount,
                                    estimated_duration: estimatedDuration,
                                    fits_duration: estimatedDuration <= (s.end_time - s.start_time),
                                  }
                                : s
                            )
                          )
                        }}
                        placeholder="Enter narration script for this segment..."
                        rows={3}
                        className="input-base w-full text-sm resize-none"
                      />
                      {seg.description && (
                        <p className="text-xs text-text-muted italic mt-1 flex items-center gap-1">
                          <Edit3 className="w-3 h-3" />
                          AI suggestion: {seg.description}
                        </p>
                      )}
                    </div>
                  </motion.div>
                ))}
              </div>
            </div>
          )}

          {/* Generated Scripts (Manual Mode) */}
          {mode === 'manual' && generatedScripts.length > 0 && (
            <div>
              <div className="flex items-center gap-2 mb-3">
                <FileText className="w-4 h-4 text-accent-red" />
                <label className="section-header mb-0">Generated Scripts</label>
              </div>

              <div className="space-y-3">
                {generatedScripts.map((script, i) => (
                  <motion.div
                    key={i}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: i * 0.1 }}
                    className={clsx(
                      'console-card p-3 border-l-4',
                      script.fits_duration ? 'border-l-green-500' : 'border-l-yellow-500'
                    )}
                  >
                    <div className="flex items-center justify-between text-xs text-text-muted mb-2">
                      <span>Segment {script.segment_index + 1}</span>
                      <div className="flex items-center gap-2">
                        <span>{script.word_count} words</span>
                        <span>~{script.estimated_duration.toFixed(1)}s</span>
                        {script.fits_duration ? (
                          <Check className="w-4 h-4 text-green-500" />
                        ) : (
                          <AlertTriangle className="w-4 h-4 text-yellow-500" />
                        )}
                      </div>
                    </div>
                    <p className="text-sm">{script.text}</p>
                  </motion.div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-terminal-border bg-terminal-bg/50 flex items-center justify-between">
          <div className="text-xs text-text-muted">
            {mode === 'auto' ? (
              autoGeneratedSegments.length > 0 ? (
                <>
                  {autoGeneratedSegments.length} segment{autoGeneratedSegments.length !== 1 ? 's' : ''} •{' '}
                  {autoGeneratedSegments.reduce((acc, s) => acc + (s.end_time - s.start_time), 0).toFixed(1)}s total
                </>
              ) : (
                <>Video: {effectiveDuration.toFixed(1)}s</>
              )
            ) : (
              <>
                {segmentInputs.length} segment{segmentInputs.length !== 1 ? 's' : ''} •{' '}
                {segmentInputs.reduce((acc, s) => acc + (s.endTime - s.startTime), 0).toFixed(1)}s total
              </>
            )}
          </div>

          <div className="flex items-center gap-2">
            {/* Auto Mode Buttons */}
            {mode === 'auto' && (
              <>
                {autoGeneratedSegments.length > 0 && (
                  <button
                    onClick={() => handleActionWithOverrideCheck('auto')}
                    disabled={isGeneratingScript}
                    className="btn-secondary flex items-center gap-2"
                  >
                    <RefreshCw className="w-4 h-4" />
                    Regenerate
                  </button>
                )}

                {autoGeneratedSegments.length === 0 ? (
                  <button
                    onClick={() => handleActionWithOverrideCheck('auto')}
                    disabled={
                      isGeneratingScript ||
                      !videoDescription.trim() ||
                      (provider === 'ollama' && !ollamaConnected)
                    }
                    className="btn-primary flex items-center gap-2"
                  >
                    {isGeneratingScript ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Wand2 className="w-4 h-4" />
                    )}
                    Auto-Generate Segments
                  </button>
                ) : (
                  <button
                    onClick={() => handleActionWithOverrideCheck('apply')}
                    disabled={applyMutation.isPending}
                    className="btn-primary flex items-center gap-2"
                  >
                    {applyMutation.isPending ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Zap className="w-4 h-4" />
                    )}
                    Apply to Timeline
                  </button>
                )}
              </>
            )}

            {/* Manual Mode Buttons */}
            {mode === 'manual' && (
              <>
                {generatedScripts.length > 0 && (
                  <button
                    onClick={() => generateMutation.mutate()}
                    disabled={isGeneratingScript}
                    className="btn-secondary flex items-center gap-2"
                  >
                    <RefreshCw className="w-4 h-4" />
                    Regenerate
                  </button>
                )}

                {generatedScripts.length === 0 ? (
                  <button
                    onClick={() => generateMutation.mutate()}
                    disabled={
                      isGeneratingScript ||
                      segmentInputs.some((s) => !s.description.trim()) ||
                      (provider === 'ollama' && !ollamaConnected)
                    }
                    className="btn-primary flex items-center gap-2"
                  >
                    {isGeneratingScript ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Wand2 className="w-4 h-4" />
                    )}
                    Generate Scripts
                  </button>
                ) : (
                  <button
                    onClick={() => handleActionWithOverrideCheck('apply')}
                    disabled={applyMutation.isPending}
                    className="btn-primary flex items-center gap-2"
                  >
                    {applyMutation.isPending ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Zap className="w-4 h-4" />
                    )}
                    Apply to Timeline
                  </button>
                )}
              </>
            )}
          </div>
        </div>
      </motion.div>
    </div>
  )
}
