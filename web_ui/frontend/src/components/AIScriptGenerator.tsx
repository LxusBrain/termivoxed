import { useState, useEffect, useMemo } from 'react'
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { motion, AnimatePresence } from 'framer-motion'
import {
  Sparkles,
  X,
  Loader2,
  Check,
  AlertTriangle,
  RefreshCw,
  Wand2,
  Settings,
  ChevronDown,
  Clock,
  FileText,
  Zap,
  LayoutGrid,
  Film,
  Edit3,
  Trash2,
  Plus,
} from 'lucide-react'
import { llmApi, segmentsApi } from '../api/client'
import { useAppStore } from '../stores/appStore'
import type { OllamaModel, GeneratedScript, SegmentDescription, AutoGeneratedSegment, VideoInfo } from '../types'
import toast from 'react-hot-toast'
import clsx from 'clsx'

interface AIScriptGeneratorProps {
  projectName: string
  videoId: string
  videoDuration: number
  isOpen: boolean
  onClose: () => void
  // Multi-video support
  videos?: VideoInfo[]
  // Video path for AI analysis
  videoPath?: string
}

type VideoScope = 'current' | 'all' | string // 'current', 'all', or specific video ID

type ProviderType = 'ollama' | 'openai' | 'anthropic' | 'azure_openai' | 'google' | 'aws_bedrock' | 'huggingface' | 'custom'
type GenerationMode = 'manual' | 'auto'

// Provider configurations with models and descriptions
const PROVIDER_CONFIG = {
  ollama: {
    name: 'Ollama',
    description: 'Local AI',
    requiresApiKey: false,
    models: [], // Dynamic from Ollama
  },
  openai: {
    name: 'OpenAI',
    description: 'GPT-4, GPT-4o',
    requiresApiKey: true,
    models: [
      { id: 'gpt-4o', name: 'GPT-4o (Latest)' },
      { id: 'gpt-4-turbo-preview', name: 'GPT-4 Turbo' },
      { id: 'gpt-4', name: 'GPT-4' },
      { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo' },
    ],
  },
  anthropic: {
    name: 'Anthropic',
    description: 'Claude 3.5, Claude 3',
    requiresApiKey: true,
    models: [
      { id: 'claude-3-5-sonnet-20241022', name: 'Claude 3.5 Sonnet (Latest)' },
      { id: 'claude-3-opus-20240229', name: 'Claude 3 Opus' },
      { id: 'claude-3-sonnet-20240229', name: 'Claude 3 Sonnet' },
      { id: 'claude-3-haiku-20240307', name: 'Claude 3 Haiku' },
    ],
  },
  azure_openai: {
    name: 'Azure OpenAI',
    description: 'Enterprise GPT',
    requiresApiKey: true,
    models: [
      { id: 'gpt-4o', name: 'GPT-4o' },
      { id: 'gpt-4', name: 'GPT-4' },
      { id: 'gpt-35-turbo', name: 'GPT-3.5 Turbo' },
    ],
  },
  google: {
    name: 'Google',
    description: 'Gemini Pro, Flash',
    requiresApiKey: true,
    models: [
      { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro' },
      { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash' },
      { id: 'gemini-pro', name: 'Gemini Pro' },
    ],
  },
  aws_bedrock: {
    name: 'AWS Bedrock',
    description: 'Claude, Llama on AWS',
    requiresApiKey: true,
    models: [
      { id: 'anthropic.claude-3-5-sonnet-20241022-v2:0', name: 'Claude 3.5 Sonnet' },
      { id: 'anthropic.claude-3-haiku-20240307-v1:0', name: 'Claude 3 Haiku' },
      { id: 'meta.llama3-70b-instruct-v1:0', name: 'Llama 3 70B' },
      { id: 'amazon.titan-text-premier-v1:0', name: 'Amazon Titan Premier' },
    ],
  },
  huggingface: {
    name: 'HuggingFace',
    description: 'Open models',
    requiresApiKey: true,
    models: [
      { id: 'meta-llama/Llama-3.1-70B-Instruct', name: 'Llama 3.1 70B' },
      { id: 'mistralai/Mixtral-8x7B-Instruct-v0.1', name: 'Mixtral 8x7B' },
      { id: 'Qwen/Qwen2.5-72B-Instruct', name: 'Qwen 2.5 72B' },
    ],
  },
  custom: {
    name: 'Custom',
    description: 'OpenAI-compatible',
    requiresApiKey: false,
    models: [{ id: 'default', name: 'Default Model' }],
  },
} as const

// All supported languages from edge-tts
const LANGUAGES = [
  { code: 'af', name: 'Afrikaans' },
  { code: 'am', name: 'Amharic' },
  { code: 'ar', name: 'Arabic' },
  { code: 'az', name: 'Azerbaijani' },
  { code: 'bg', name: 'Bulgarian' },
  { code: 'bn', name: 'Bengali' },
  { code: 'bs', name: 'Bosnian' },
  { code: 'ca', name: 'Catalan' },
  { code: 'cs', name: 'Czech' },
  { code: 'cy', name: 'Welsh' },
  { code: 'da', name: 'Danish' },
  { code: 'de', name: 'German' },
  { code: 'el', name: 'Greek' },
  { code: 'en', name: 'English' },
  { code: 'es', name: 'Spanish' },
  { code: 'et', name: 'Estonian' },
  { code: 'fa', name: 'Persian' },
  { code: 'fi', name: 'Finnish' },
  { code: 'fil', name: 'Filipino' },
  { code: 'fr', name: 'French' },
  { code: 'ga', name: 'Irish' },
  { code: 'gl', name: 'Galician' },
  { code: 'gu', name: 'Gujarati' },
  { code: 'he', name: 'Hebrew' },
  { code: 'hi', name: 'Hindi' },
  { code: 'hr', name: 'Croatian' },
  { code: 'hu', name: 'Hungarian' },
  { code: 'id', name: 'Indonesian' },
  { code: 'is', name: 'Icelandic' },
  { code: 'it', name: 'Italian' },
  { code: 'iu', name: 'Inuktitut' },
  { code: 'ja', name: 'Japanese' },
  { code: 'jv', name: 'Javanese' },
  { code: 'ka', name: 'Georgian' },
  { code: 'kk', name: 'Kazakh' },
  { code: 'km', name: 'Khmer' },
  { code: 'kn', name: 'Kannada' },
  { code: 'ko', name: 'Korean' },
  { code: 'lo', name: 'Lao' },
  { code: 'lt', name: 'Lithuanian' },
  { code: 'lv', name: 'Latvian' },
  { code: 'mk', name: 'Macedonian' },
  { code: 'ml', name: 'Malayalam' },
  { code: 'mn', name: 'Mongolian' },
  { code: 'mr', name: 'Marathi' },
  { code: 'ms', name: 'Malay' },
  { code: 'mt', name: 'Maltese' },
  { code: 'my', name: 'Myanmar' },
  { code: 'nb', name: 'Norwegian' },
  { code: 'ne', name: 'Nepali' },
  { code: 'nl', name: 'Dutch' },
  { code: 'pl', name: 'Polish' },
  { code: 'ps', name: 'Pashto' },
  { code: 'pt', name: 'Portuguese' },
  { code: 'ro', name: 'Romanian' },
  { code: 'ru', name: 'Russian' },
  { code: 'si', name: 'Sinhala' },
  { code: 'sk', name: 'Slovak' },
  { code: 'sl', name: 'Slovenian' },
  { code: 'so', name: 'Somali' },
  { code: 'sq', name: 'Albanian' },
  { code: 'sr', name: 'Serbian' },
  { code: 'su', name: 'Sundanese' },
  { code: 'sv', name: 'Swedish' },
  { code: 'sw', name: 'Swahili' },
  { code: 'ta', name: 'Tamil' },
  { code: 'te', name: 'Telugu' },
  { code: 'th', name: 'Thai' },
  { code: 'tr', name: 'Turkish' },
  { code: 'uk', name: 'Ukrainian' },
  { code: 'ur', name: 'Urdu' },
  { code: 'uz', name: 'Uzbek' },
  { code: 'vi', name: 'Vietnamese' },
  { code: 'zh', name: 'Chinese' },
  { code: 'zu', name: 'Zulu' },
]

interface SegmentInput {
  id: string
  startTime: number
  endTime: number
  description: string
}

export default function AIScriptGenerator({
  projectName,
  videoId,
  videoDuration,
  isOpen,
  onClose,
  videos = [],
  videoPath: _videoPath,  // Reserved for future AI video analysis feature
}: AIScriptGeneratorProps) {
  const queryClient = useQueryClient()
  const { segments: existingSegments, setSegments, isGeneratingScript, setIsGeneratingScript } = useAppStore()

  // Multi-video support
  const hasMultipleVideos = videos.length > 1
  const [videoScope, setVideoScope] = useState<VideoScope>('current')

  // Get target video(s) based on scope
  const getTargetVideos = useMemo(() => {
    if (videoScope === 'current') {
      const currentVideo = videos.find(v => v.id === videoId)
      return currentVideo ? [currentVideo] : []
    } else if (videoScope === 'all') {
      return videos.filter(v => v.file_exists)
    } else {
      // Specific video ID
      const specificVideo = videos.find(v => v.id === videoScope)
      return specificVideo ? [specificVideo] : []
    }
  }, [videoScope, videoId, videos])

  // Get effective duration based on scope
  const effectiveDuration = useMemo(() => {
    if (videoScope === 'current') return videoDuration
    if (videoScope === 'all') {
      // Total duration of all videos
      return videos.reduce((sum, v) => sum + (v.duration || 0), 0)
    }
    // Specific video
    const video = videos.find(v => v.id === videoScope)
    return video?.duration || videoDuration
  }, [videoScope, videoDuration, videos])

  // Get effective video ID for segment creation
  const getEffectiveVideoId = () => {
    if (videoScope === 'current') return videoId
    if (videoScope === 'all') return undefined // Segments will be split across videos
    return videoScope // Specific video ID
  }

  // Generation mode: 'manual' = define segments yourself, 'auto' = AI decides segments
  const [mode, setMode] = useState<GenerationMode>('auto')

  // Confirmation dialog for overriding existing segments
  const [showOverrideConfirm, setShowOverrideConfirm] = useState(false)
  const [pendingAction, setPendingAction] = useState<'auto' | 'apply' | null>(null)

  // Provider state
  const [provider, setProvider] = useState<ProviderType>('ollama')
  const [model, setModel] = useState('')
  const [apiKey, setApiKey] = useState('')
  const [customEndpoint, setCustomEndpoint] = useState('')

  // Azure OpenAI specific
  const [azureEndpoint, setAzureEndpoint] = useState('')
  const [azureDeployment, setAzureDeployment] = useState('')
  const [azureApiVersion, setAzureApiVersion] = useState('2024-05-01-preview')

  // AWS Bedrock specific
  const [awsRegion, setAwsRegion] = useState('us-east-1')
  const [awsAccessKeyId, setAwsAccessKeyId] = useState('')
  const [awsSecretAccessKey, setAwsSecretAccessKey] = useState('')

  // HuggingFace specific
  const [hfProvider, setHfProvider] = useState<string>('auto')

  // Style settings
  const [tone, setTone] = useState('documentary')
  const [style, setStyle] = useState('narrative')
  const [audience, setAudience] = useState('general')
  const [language, setLanguage] = useState('en')

  // Auto mode settings
  const [videoDescription, setVideoDescription] = useState('')
  const [videoTitle, setVideoTitle] = useState('')
  const [minSegmentDuration, setMinSegmentDuration] = useState(5)
  const [maxSegmentDuration, setMaxSegmentDuration] = useState(30)

  // Segment inputs (for manual mode)
  const [segmentInputs, setSegmentInputs] = useState<SegmentInput[]>([
    { id: '1', startTime: 0, endTime: Math.min(15, videoDuration), description: '' },
  ])

  // Generated scripts
  const [generatedScripts, setGeneratedScripts] = useState<GeneratedScript[]>([])
  const [autoGeneratedSegments, setAutoGeneratedSegments] = useState<AutoGeneratedSegment[]>([])
  const [showAdvanced, setShowAdvanced] = useState(false)

  // Generation progress state
  const [generationProgress, setGenerationProgress] = useState<{
    stage: string
    message: string
    progress: number
    detail?: string
    segmentCount: number
    segmentsValidated: number
    segmentsRefined: number
    refinementAttempt: number
    maxRefinements: number
  } | null>(null)

  // Check if there are existing segments
  const hasExistingSegments = existingSegments.length > 0

  // Calculate timeline coverage for mini timeline
  const timelineMarkers = useMemo(() => {
    const duration = effectiveDuration
    const interval = duration > 300 ? 60 : duration > 60 ? 10 : 5
    const count = Math.floor(duration / interval)
    return Array.from({ length: count + 1 }, (_, i) => i * interval)
  }, [effectiveDuration])

  // Initialize manual mode with existing segments when switching modes
  useEffect(() => {
    if (mode === 'manual' && hasExistingSegments && segmentInputs.length === 1 && !segmentInputs[0].description) {
      // Load existing segments into manual mode
      const loadedSegments = existingSegments.map((seg) => ({
        id: seg.id,
        startTime: seg.start_time,
        endTime: seg.end_time,
        description: seg.text || '',
      }))
      setSegmentInputs(loadedSegments)
    }
  }, [mode, hasExistingSegments, existingSegments])

  // Fetch Ollama models
  const { data: ollamaData } = useQuery({
    queryKey: ['ollama-models'],
    queryFn: () => llmApi.listOllamaModels(),
    enabled: provider === 'ollama',
  })

  const ollamaModels: OllamaModel[] = ollamaData?.data?.models || []
  const ollamaConnected = ollamaData?.data?.connected ?? false

  // Set model to first available when models load or provider changes
  useEffect(() => {
    if (provider === 'ollama') {
      if (ollamaModels.length > 0) {
        setModel(ollamaModels[0].name)
      }
    } else if (provider === 'azure_openai') {
      // For Azure, use deployment name as model if set, otherwise first model
      if (azureDeployment) {
        setModel(azureDeployment)
      } else {
        setModel(PROVIDER_CONFIG.azure_openai.models[0].id)
      }
    } else {
      // For other providers, use first model from config
      const config = PROVIDER_CONFIG[provider]
      if (config.models.length > 0) {
        setModel(config.models[0].id)
      }
    }
  }, [provider, ollamaModels, azureDeployment])

  // Add segment
  const addSegment = () => {
    const lastSegment = segmentInputs[segmentInputs.length - 1]
    const newStart = lastSegment ? lastSegment.endTime : 0
    const newEnd = Math.min(newStart + 15, videoDuration)

    if (newStart >= videoDuration) {
      toast.error('Cannot add more segments - video duration reached')
      return
    }

    setSegmentInputs([
      ...segmentInputs,
      {
        id: Date.now().toString(),
        startTime: newStart,
        endTime: newEnd,
        description: '',
      },
    ])
  }

  // Remove segment
  const removeSegment = (id: string) => {
    if (segmentInputs.length === 1) return
    setSegmentInputs(segmentInputs.filter((s) => s.id !== id))
  }

  // Update segment
  const updateSegment = (id: string, field: keyof SegmentInput, value: string | number) => {
    setSegmentInputs(
      segmentInputs.map((s) => (s.id === id ? { ...s, [field]: value } : s))
    )
  }

  // Update auto-generated segment (make editable)
  const updateAutoSegment = (index: number, field: keyof AutoGeneratedSegment, value: string | number) => {
    setAutoGeneratedSegments(
      autoGeneratedSegments.map((s, i) => (i === index ? { ...s, [field]: value } : s))
    )
  }

  // Remove auto-generated segment
  const removeAutoSegment = (index: number) => {
    setAutoGeneratedSegments(autoGeneratedSegments.filter((_, i) => i !== index))
  }

  // Handle action with override check
  const handleActionWithOverrideCheck = (action: 'auto' | 'apply') => {
    if (hasExistingSegments) {
      setPendingAction(action)
      setShowOverrideConfirm(true)
    } else {
      executeAction(action)
    }
  }

  // Execute the pending action
  const executeAction = (action: 'auto' | 'apply') => {
    if (action === 'auto') {
      autoSegmentMutation.mutate()
    } else if (action === 'apply') {
      applyMutation.mutate()
    }
    setShowOverrideConfirm(false)
    setPendingAction(null)
  }

  // Format time helper
  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  // Build provider config with all provider-specific fields
  const buildProviderConfig = () => {
    const baseConfig: Record<string, unknown> = {
      type: provider,
      model,
    }

    // Add API key if provided
    if (apiKey) {
      baseConfig.api_key = apiKey
    }

    // Provider-specific configuration
    switch (provider) {
      case 'azure_openai':
        baseConfig.endpoint = azureEndpoint || undefined
        baseConfig.azure_deployment = azureDeployment || model
        baseConfig.azure_api_version = azureApiVersion
        break
      case 'aws_bedrock':
        baseConfig.aws_region = awsRegion
        baseConfig.aws_access_key_id = awsAccessKeyId || undefined
        baseConfig.aws_secret_access_key = awsSecretAccessKey || undefined
        break
      case 'huggingface':
        baseConfig.huggingface_provider = hfProvider
        break
      case 'custom':
        baseConfig.endpoint = customEndpoint || undefined
        break
      default:
        break
    }

    return baseConfig
  }

  // Generate mutation (manual mode)
  const generateMutation = useMutation({
    mutationFn: async () => {
      const segments: SegmentDescription[] = segmentInputs.map((s) => ({
        start_time: s.startTime,
        end_time: s.endTime,
        description: s.description,
      }))

      const providerConfig = buildProviderConfig()

      const response = await llmApi.generateScript({
        provider: providerConfig,
        segments,
        style: { tone, style, audience, length: 'moderate', language },
        fit_to_duration: true,
      })

      return response.data
    },
    onMutate: () => {
      setIsGeneratingScript(true)
    },
    onSuccess: (data) => {
      setGeneratedScripts(data.scripts)
      setIsGeneratingScript(false)

      if (data.all_fit) {
        toast.success('Scripts generated successfully!')
      } else {
        toast('Some scripts may not fit their segments')
      }
    },
    onError: (error: Error) => {
      setIsGeneratingScript(false)
      toast.error(error.message || 'Failed to generate scripts')
    },
  })

  // Auto-segment mutation (auto mode) - now using intelligent endpoint with video analysis
  const autoSegmentMutation = useMutation({
    mutationFn: async () => {
      const providerConfig = buildProviderConfig()

      // Use the new intelligent endpoint with optional video analysis
      const response = await llmApi.intelligentAutoSegment({
        provider: providerConfig,
        video_duration: effectiveDuration,
        video_description: videoDescription,
        video_title: videoTitle || undefined,
        style: { tone, style, audience, length: 'moderate', language },
        min_segment_duration: minSegmentDuration,
        max_segment_duration: maxSegmentDuration,
        max_refinement_iterations: 3,
        stream: false,
      })

      return response.data
    },
    onMutate: () => {
      setIsGeneratingScript(true)
      setGenerationProgress({
        stage: 'initializing',
        message: 'Starting intelligent script generation...',
        progress: 5,
        segmentCount: 0,
        segmentsValidated: 0,
        segmentsRefined: 0,
        refinementAttempt: 0,
        maxRefinements: 3,
      })
    },
    onSuccess: (data) => {
      // Transform response to match expected format
      const segments = data.segments.map((seg: Record<string, unknown>) => ({
        segment_index: seg.segment_index,
        name: seg.name,
        start_time: seg.start_time,
        end_time: seg.end_time,
        description: seg.description,
        script: seg.script,
        estimated_duration: seg.estimated_duration,
        word_count: seg.word_count,
        fits_duration: seg.fits_duration,
      }))

      setAutoGeneratedSegments(segments)
      setIsGeneratingScript(false)
      setGenerationProgress(null)

      const allFit = data.all_fit
      const totalSegments = data.total_segments
      const coverage = data.coverage_percent

      if (allFit) {
        toast.success(`${totalSegments} segments generated (${coverage?.toFixed(0) || 0}% coverage)`)
      } else {
        toast(`${totalSegments} segments generated with timing adjustments`)
      }

      // Show refinement info if any
      if (data.refinement_iterations > 0) {
        toast.success(`${data.refinement_iterations} segment(s) refined for better fit`)
      }

      if (data.warnings && data.warnings.length > 0) {
        data.warnings.slice(0, 3).forEach((w: string) => toast(w))
      }
    },
    onError: (error: Error) => {
      setIsGeneratingScript(false)
      setGenerationProgress(null)
      toast.error(error.message || 'Failed to auto-generate segments')
    },
  })

  // Apply scripts mutation (works for both modes)
  const applyMutation = useMutation({
    mutationFn: async () => {
      let segments

      if (mode === 'auto' && autoGeneratedSegments.length > 0) {
        // Auto mode: use auto-generated segments with their names and scripts
        segments = autoGeneratedSegments.map((seg) => ({
          name: seg.name,
          start_time: seg.start_time,
          end_time: seg.end_time,
          text: seg.script,
          language,
        }))
      } else {
        // Manual mode: use generated scripts
        segments = generatedScripts.map((script, i) => ({
          name: `Segment ${i + 1}`,
          start_time: script.start_time,
          end_time: script.end_time,
          text: script.text,
          language,
        }))
      }

      const response = await segmentsApi.createBatch(projectName, segments, getEffectiveVideoId())
      return response.data
    },
    onSuccess: (data) => {
      setSegments(data.segments)
      // Invalidate the segments query to ensure ProjectPage gets fresh data
      queryClient.invalidateQueries({ queryKey: ['segments', projectName] })
      toast.success(`${data.created} segments created!`)
      onClose()
    },
    onError: (error: unknown) => {
      const axiosError = error as { response?: { data?: { detail?: string; errors?: Array<{ index: number; error: string }> } } }
      // Check for individual segment errors in batch response
      const errors = axiosError?.response?.data?.errors
      if (errors && errors.length > 0) {
        // Show the first error message with context
        const firstError = errors[0]
        toast.error(`Segment ${firstError.index + 1} failed: ${firstError.error}`)
      } else {
        // Fallback to detail or generic message
        const errorMessage = axiosError?.response?.data?.detail || 'Failed to apply scripts'
        toast.error(errorMessage)
      }
    },
  })

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" onClick={onClose} />

      {/* Override Confirmation Dialog */}
      <AnimatePresence>
        {showOverrideConfirm && (
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            className="absolute z-50 bg-terminal-surface border border-yellow-500/50 rounded-lg p-4 max-w-md mx-4 shadow-lg"
          >
            <div className="flex items-start gap-3 mb-4">
              <div className="w-10 h-10 rounded-lg bg-yellow-500/20 flex items-center justify-center shrink-0">
                <AlertTriangle className="w-5 h-5 text-yellow-500" />
              </div>
              <div>
                <h3 className="font-semibold text-yellow-500">Replace Existing Segments?</h3>
                <p className="text-sm text-text-muted mt-1">
                  You have {existingSegments.length} existing segment{existingSegments.length !== 1 ? 's' : ''} on the timeline.
                  This action will replace all existing segments with the new ones.
                </p>
              </div>
            </div>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setShowOverrideConfirm(false)
                  setPendingAction(null)
                }}
                className="btn-secondary text-sm"
              >
                Cancel
              </button>
              <button
                onClick={() => pendingAction && executeAction(pendingAction)}
                className="btn-primary bg-yellow-600 hover:bg-yellow-700 text-sm"
              >
                Yes, Replace
              </button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      <motion.div
        initial={{ opacity: 0, scale: 0.95, y: 20 }}
        animate={{ opacity: 1, scale: 1, y: 0 }}
        exit={{ opacity: 0, scale: 0.95, y: 20 }}
        className="relative bg-terminal-surface border border-terminal-border rounded-lg w-full max-w-4xl mx-4 max-h-[90vh] flex flex-col overflow-hidden"
      >
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-terminal-border bg-terminal-bg/50">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-lg bg-accent-red/20 flex items-center justify-center border border-accent-red/30">
              <Sparkles className="w-5 h-5 text-accent-red" />
            </div>
            <div>
              <h2 className="font-semibold">AI Script Generator</h2>
              <p className="text-xs text-text-muted">Generate narration scripts with AI</p>
            </div>
          </div>
          <button onClick={onClose} className="p-2 rounded hover:bg-terminal-elevated text-text-muted">
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4 space-y-6">
          {/* Mode Selection */}
          <div className="grid grid-cols-2 gap-2">
            <button
              onClick={() => {
                setMode('auto')
                setGeneratedScripts([])
              }}
              className={clsx(
                'p-3 rounded-lg border text-sm transition-all text-left',
                mode === 'auto'
                  ? 'bg-accent-red/20 border-accent-red'
                  : 'bg-terminal-elevated border-terminal-border hover:border-accent-red/50'
              )}
            >
              <div className="flex items-center gap-2">
                <Film className={clsx('w-5 h-5', mode === 'auto' ? 'text-accent-red' : 'text-text-muted')} />
                <div>
                  <div className={clsx('font-medium', mode === 'auto' ? 'text-accent-red' : 'text-text-primary')}>
                    Auto-Generate Segments
                  </div>
                  <div className="text-[10px] text-text-muted mt-0.5">
                    Describe video, AI creates segments & scripts
                  </div>
                </div>
              </div>
            </button>
            <button
              onClick={() => {
                setMode('manual')
                setAutoGeneratedSegments([])
              }}
              className={clsx(
                'p-3 rounded-lg border text-sm transition-all text-left',
                mode === 'manual'
                  ? 'bg-accent-red/20 border-accent-red'
                  : 'bg-terminal-elevated border-terminal-border hover:border-accent-red/50'
              )}
            >
              <div className="flex items-center gap-2">
                <LayoutGrid className={clsx('w-5 h-5', mode === 'manual' ? 'text-accent-red' : 'text-text-muted')} />
                <div>
                  <div className={clsx('font-medium', mode === 'manual' ? 'text-accent-red' : 'text-text-primary')}>
                    Define Segments Manually
                  </div>
                  <div className="text-[10px] text-text-muted mt-0.5">
                    Set timing yourself, AI writes scripts
                  </div>
                </div>
              </div>
            </button>
          </div>

          {/* Video Scope Selector (only show when multiple videos) */}
          {hasMultipleVideos && (
            <div className="console-card p-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Film className="w-4 h-4 text-text-muted" />
                  <span className="text-sm text-text-secondary">Generate scripts for:</span>
                </div>
                <select
                  value={videoScope}
                  onChange={(e) => setVideoScope(e.target.value as VideoScope)}
                  className="input-base py-1 px-2 text-sm min-w-[150px]"
                >
                  <option value="current">Current Video</option>
                  <option value="all">All Videos ({videos.length})</option>
                  {videos.map((v) => (
                    <option key={v.id} value={v.id} disabled={!v.file_exists}>
                      {v.name} ({formatTime(v.duration || 0)})
                      {!v.file_exists && ' (missing)'}
                    </option>
                  ))}
                </select>
              </div>
              {videoScope === 'all' && (
                <p className="text-xs text-text-muted mt-2">
                  Total duration: {formatTime(effectiveDuration)} across {getTargetVideos.length} video{getTargetVideos.length !== 1 ? 's' : ''}
                </p>
              )}
            </div>
          )}

          {/* Mini Timeline - Show existing segments */}
          <div className="console-card p-3">
            <div className="flex items-center justify-between mb-2">
              <span className="text-xs text-text-muted">
                Timeline: {formatTime(effectiveDuration)} ({existingSegments.length} existing segment{existingSegments.length !== 1 ? 's' : ''})
              </span>
              {hasExistingSegments && (
                <span className="text-xs text-yellow-500 flex items-center gap-1">
                  <AlertTriangle className="w-3 h-3" />
                  New segments will replace existing
                </span>
              )}
            </div>

            {/* Mini timeline track */}
            <div className="relative h-8 bg-terminal-bg rounded border border-terminal-border">
              {/* Time markers */}
              {timelineMarkers.map((time) => (
                <div
                  key={time}
                  className="absolute top-0 bottom-0 w-px bg-terminal-border/50"
                  style={{ left: `${(time / effectiveDuration) * 100}%` }}
                />
              ))}

              {/* Existing segments */}
              {existingSegments.map((seg) => (
                <div
                  key={seg.id}
                  className="absolute top-1 bottom-1 bg-accent-red/30 border border-accent-red/50 rounded"
                  style={{
                    left: `${(seg.start_time / effectiveDuration) * 100}%`,
                    width: `${((seg.end_time - seg.start_time) / effectiveDuration) * 100}%`,
                    minWidth: '4px',
                  }}
                  title={`${seg.name}: ${seg.start_time.toFixed(1)}s - ${seg.end_time.toFixed(1)}s`}
                />
              ))}

              {/* Auto-generated segments preview (overlay in different color) */}
              {autoGeneratedSegments.map((seg, i) => (
                <div
                  key={`auto-${i}`}
                  className="absolute top-1 bottom-1 bg-green-500/30 border border-green-500/50 rounded"
                  style={{
                    left: `${(seg.start_time / effectiveDuration) * 100}%`,
                    width: `${((seg.end_time - seg.start_time) / effectiveDuration) * 100}%`,
                    minWidth: '4px',
                  }}
                  title={`${seg.name}: ${seg.start_time.toFixed(1)}s - ${seg.end_time.toFixed(1)}s`}
                />
              ))}

              {/* Empty state */}
              {existingSegments.length === 0 && autoGeneratedSegments.length === 0 && (
                <div className="absolute inset-0 flex items-center justify-center text-text-muted text-[10px]">
                  No segments defined yet
                </div>
              )}
            </div>

            {/* Legend */}
            <div className="flex items-center gap-4 mt-2 text-[10px] text-text-muted">
              {hasExistingSegments && (
                <div className="flex items-center gap-1">
                  <div className="w-3 h-2 bg-accent-red/30 border border-accent-red/50 rounded" />
                  <span>Existing</span>
                </div>
              )}
              {autoGeneratedSegments.length > 0 && (
                <div className="flex items-center gap-1">
                  <div className="w-3 h-2 bg-green-500/30 border border-green-500/50 rounded" />
                  <span>Generated (preview)</span>
                </div>
              )}
            </div>
          </div>

          {/* Provider Selection - All 8 Providers */}
          <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
            {(Object.keys(PROVIDER_CONFIG) as ProviderType[]).map((p) => {
              const config = PROVIDER_CONFIG[p]
              return (
                <button
                  key={p}
                  onClick={() => setProvider(p)}
                  className={clsx(
                    'p-2 rounded-lg border text-sm transition-all text-left',
                    provider === p
                      ? 'bg-accent-red/20 border-accent-red text-accent-red'
                      : 'bg-terminal-elevated border-terminal-border text-text-secondary hover:border-accent-red/50'
                  )}
                >
                  <div className="font-medium text-xs">{config.name}</div>
                  <div className="text-[10px] text-text-muted mt-0.5 truncate">
                    {config.description}
                  </div>
                </button>
              )
            })}
          </div>

          {/* Provider-specific settings */}
          <div className="console-card p-4 space-y-4">
            {/* Ollama Provider */}
            {provider === 'ollama' && (
              <div>
                <label className="section-header">Ollama Model</label>
                {!ollamaConnected ? (
                  <div className="flex items-center gap-2 text-yellow-500 text-sm">
                    <AlertTriangle className="w-4 h-4" />
                    <span>Ollama not running. Start with: <code className="bg-terminal-bg px-1 rounded">ollama serve</code></span>
                  </div>
                ) : (
                  <select
                    value={model}
                    onChange={(e) => setModel(e.target.value)}
                    className="input-base w-full"
                  >
                    {ollamaModels.map((m) => (
                      <option key={m.name} value={m.name}>
                        {m.name} ({m.size})
                      </option>
                    ))}
                  </select>
                )}
              </div>
            )}

            {/* OpenAI, Anthropic, Google - Simple API Key + Model */}
            {(provider === 'openai' || provider === 'anthropic' || provider === 'google') && (
              <div className="space-y-3">
                <div>
                  <label className="section-header">API Key</label>
                  <input
                    type="password"
                    value={apiKey}
                    onChange={(e) => setApiKey(e.target.value)}
                    placeholder={`Enter your ${PROVIDER_CONFIG[provider].name} API key`}
                    className="input-base w-full font-mono"
                  />
                </div>
                <div>
                  <label className="section-header">Model</label>
                  <select
                    value={model}
                    onChange={(e) => setModel(e.target.value)}
                    className="input-base w-full"
                  >
                    {PROVIDER_CONFIG[provider].models.map((m) => (
                      <option key={m.id} value={m.id}>{m.name}</option>
                    ))}
                  </select>
                </div>
              </div>
            )}

            {/* Azure OpenAI - Requires endpoint, deployment, API version */}
            {provider === 'azure_openai' && (
              <div className="space-y-3">
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">Azure Endpoint</label>
                    <input
                      type="text"
                      value={azureEndpoint}
                      onChange={(e) => setAzureEndpoint(e.target.value)}
                      placeholder="https://your-resource.openai.azure.com"
                      className="input-base w-full font-mono text-xs"
                    />
                  </div>
                  <div>
                    <label className="section-header">API Key</label>
                    <input
                      type="password"
                      value={apiKey}
                      onChange={(e) => setApiKey(e.target.value)}
                      placeholder="Azure OpenAI API key"
                      className="input-base w-full font-mono"
                    />
                  </div>
                </div>
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">Deployment Name</label>
                    <input
                      type="text"
                      value={azureDeployment}
                      onChange={(e) => setAzureDeployment(e.target.value)}
                      placeholder="e.g., gpt-35-turbo"
                      className="input-base w-full font-mono"
                    />
                  </div>
                  <div>
                    <label className="section-header">API Version</label>
                    <select
                      value={azureApiVersion}
                      onChange={(e) => setAzureApiVersion(e.target.value)}
                      className="input-base w-full"
                    >
                      <option value="2024-05-01-preview">2024-05-01-preview (Latest)</option>
                      <option value="2024-02-15-preview">2024-02-15-preview</option>
                      <option value="2023-12-01-preview">2023-12-01-preview</option>
                      <option value="2023-05-15">2023-05-15 (GA)</option>
                    </select>
                  </div>
                </div>
                <p className="text-xs text-text-muted">
                  Find these values in your Azure Portal → Azure OpenAI resource → Keys and Endpoint
                </p>
              </div>
            )}

            {/* AWS Bedrock - Requires region, credentials */}
            {provider === 'aws_bedrock' && (
              <div className="space-y-3">
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">AWS Region</label>
                    <select
                      value={awsRegion}
                      onChange={(e) => setAwsRegion(e.target.value)}
                      className="input-base w-full"
                    >
                      <option value="us-east-1">US East (N. Virginia)</option>
                      <option value="us-west-2">US West (Oregon)</option>
                      <option value="eu-west-1">EU (Ireland)</option>
                      <option value="eu-central-1">EU (Frankfurt)</option>
                      <option value="ap-southeast-1">Asia Pacific (Singapore)</option>
                      <option value="ap-northeast-1">Asia Pacific (Tokyo)</option>
                    </select>
                  </div>
                  <div>
                    <label className="section-header">Model</label>
                    <select
                      value={model}
                      onChange={(e) => setModel(e.target.value)}
                      className="input-base w-full"
                    >
                      {PROVIDER_CONFIG.aws_bedrock.models.map((m) => (
                        <option key={m.id} value={m.id}>{m.name}</option>
                      ))}
                    </select>
                  </div>
                </div>
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">Access Key ID</label>
                    <input
                      type="password"
                      value={awsAccessKeyId}
                      onChange={(e) => setAwsAccessKeyId(e.target.value)}
                      placeholder="AKIA..."
                      className="input-base w-full font-mono"
                    />
                  </div>
                  <div>
                    <label className="section-header">Secret Access Key</label>
                    <input
                      type="password"
                      value={awsSecretAccessKey}
                      onChange={(e) => setAwsSecretAccessKey(e.target.value)}
                      placeholder="Secret key"
                      className="input-base w-full font-mono"
                    />
                  </div>
                </div>
                <p className="text-xs text-text-muted">
                  Leave credentials empty to use environment variables or IAM role
                </p>
              </div>
            )}

            {/* HuggingFace - API key + inference provider */}
            {provider === 'huggingface' && (
              <div className="space-y-3">
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">API Token</label>
                    <input
                      type="password"
                      value={apiKey}
                      onChange={(e) => setApiKey(e.target.value)}
                      placeholder="hf_..."
                      className="input-base w-full font-mono"
                    />
                  </div>
                  <div>
                    <label className="section-header">Inference Provider</label>
                    <select
                      value={hfProvider}
                      onChange={(e) => setHfProvider(e.target.value)}
                      className="input-base w-full"
                    >
                      <option value="auto">Auto (Recommended)</option>
                      <option value="together">Together AI</option>
                      <option value="hyperbolic">Hyperbolic</option>
                      <option value="nebius">Nebius</option>
                    </select>
                  </div>
                </div>
                <div>
                  <label className="section-header">Model</label>
                  <select
                    value={model}
                    onChange={(e) => setModel(e.target.value)}
                    className="input-base w-full"
                  >
                    {PROVIDER_CONFIG.huggingface.models.map((m) => (
                      <option key={m.id} value={m.id}>{m.name}</option>
                    ))}
                  </select>
                </div>
                <p className="text-xs text-text-muted">
                  Get your API token from huggingface.co/settings/tokens
                </p>
              </div>
            )}

            {/* Custom OpenAI-compatible endpoint */}
            {provider === 'custom' && (
              <div className="space-y-3">
                <div>
                  <label className="section-header">Endpoint URL</label>
                  <input
                    type="text"
                    value={customEndpoint}
                    onChange={(e) => setCustomEndpoint(e.target.value)}
                    placeholder="https://your-api.com/v1"
                    className="input-base w-full font-mono"
                  />
                </div>
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">API Key (optional)</label>
                    <input
                      type="password"
                      value={apiKey}
                      onChange={(e) => setApiKey(e.target.value)}
                      placeholder="API key if required"
                      className="input-base w-full font-mono"
                    />
                  </div>
                  <div>
                    <label className="section-header">Model Name</label>
                    <input
                      type="text"
                      value={model}
                      onChange={(e) => setModel(e.target.value)}
                      placeholder="model-name"
                      className="input-base w-full font-mono"
                    />
                  </div>
                </div>
                <p className="text-xs text-text-muted">
                  Works with any OpenAI-compatible API (LM Studio, vLLM, LocalAI, etc.)
                </p>
              </div>
            )}
          </div>

          {/* Style Settings */}
          <div>
            <button
              onClick={() => setShowAdvanced(!showAdvanced)}
              className="flex items-center gap-2 text-sm text-text-muted hover:text-text-primary mb-3"
            >
              <Settings className="w-4 h-4" />
              <span>Style Settings</span>
              <ChevronDown className={clsx('w-4 h-4 transition-transform', showAdvanced && 'rotate-180')} />
            </button>

            <AnimatePresence>
              {showAdvanced && (
                <motion.div
                  initial={{ height: 0, opacity: 0 }}
                  animate={{ height: 'auto', opacity: 1 }}
                  exit={{ height: 0, opacity: 0 }}
                  className="overflow-hidden"
                >
                  <div className="grid grid-cols-2 lg:grid-cols-4 gap-3 console-card p-4">
                    <div>
                      <label className="section-header">Tone</label>
                      <select value={tone} onChange={(e) => setTone(e.target.value)} className="input-base w-full">
                        <option value="documentary">Documentary</option>
                        <option value="professional">Professional</option>
                        <option value="casual">Casual</option>
                        <option value="dramatic">Dramatic</option>
                        <option value="educational">Educational</option>
                      </select>
                    </div>
                    <div>
                      <label className="section-header">Style</label>
                      <select value={style} onChange={(e) => setStyle(e.target.value)} className="input-base w-full">
                        <option value="narrative">Narrative</option>
                        <option value="conversational">Conversational</option>
                        <option value="instructional">Instructional</option>
                        <option value="storytelling">Storytelling</option>
                      </select>
                    </div>
                    <div>
                      <label className="section-header">Audience</label>
                      <select value={audience} onChange={(e) => setAudience(e.target.value)} className="input-base w-full">
                        <option value="general">General</option>
                        <option value="technical">Technical</option>
                        <option value="children">Children</option>
                        <option value="business">Business</option>
                      </select>
                    </div>
                    <div>
                      <label className="section-header">Language</label>
                      <select value={language} onChange={(e) => setLanguage(e.target.value)} className="input-base w-full">
                        {LANGUAGES.map((lang) => (
                          <option key={lang.code} value={lang.code}>
                            {lang.name}
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>
                </motion.div>
              )}
            </AnimatePresence>
          </div>

          {/* Auto Mode: Video Description */}
          {mode === 'auto' && (
            <div className="space-y-4">
              <div className="console-card p-4 space-y-4">
                <div>
                  <label className="section-header">Video Title (optional)</label>
                  <input
                    type="text"
                    value={videoTitle}
                    onChange={(e) => setVideoTitle(e.target.value)}
                    placeholder="e.g., Product Demo, Travel Vlog, Tutorial..."
                    className="input-base w-full"
                  />
                </div>
                <div>
                  <label className="section-header">
                    Video Description <span className="text-accent-red">*</span>
                  </label>
                  <textarea
                    value={videoDescription}
                    onChange={(e) => setVideoDescription(e.target.value)}
                    placeholder="Describe what happens in your video from start to finish. Be specific about key moments, transitions, and what should be narrated. The AI will use this to create optimal segment breakdowns with scripts..."
                    rows={5}
                    className="input-base w-full text-sm resize-none"
                  />
                  <p className="text-xs text-text-muted mt-1">
                    Video duration: {effectiveDuration.toFixed(1)}s ({(effectiveDuration / 60).toFixed(1)} min)
                  </p>
                </div>
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="section-header">Min Segment Duration</label>
                    <div className="flex items-center gap-2">
                      <input
                        type="number"
                        min="3"
                        max={maxSegmentDuration}
                        value={minSegmentDuration}
                        onChange={(e) => setMinSegmentDuration(Number(e.target.value))}
                        className="input-base w-20 font-mono"
                      />
                      <span className="text-xs text-text-muted">seconds</span>
                    </div>
                  </div>
                  <div>
                    <label className="section-header">Max Segment Duration</label>
                    <div className="flex items-center gap-2">
                      <input
                        type="number"
                        min={minSegmentDuration}
                        max="120"
                        value={maxSegmentDuration}
                        onChange={(e) => setMaxSegmentDuration(Number(e.target.value))}
                        className="input-base w-20 font-mono"
                      />
                      <span className="text-xs text-text-muted">seconds</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Manual Mode: Segment Descriptions */}
          {mode === 'manual' && (
            <div>
              <div className="flex items-center justify-between mb-3">
                <label className="section-header mb-0">Segment Descriptions</label>
                <button onClick={addSegment} className="btn-secondary text-xs py-1 px-2">
                  + Add Segment
                </button>
              </div>

              <div className="space-y-3">
                {segmentInputs.map((seg, i) => (
                  <motion.div
                    key={seg.id}
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="console-card p-3"
                  >
                    <div className="flex items-start gap-3">
                      <div className="w-8 h-8 rounded bg-accent-red/20 flex items-center justify-center text-accent-red font-mono text-sm shrink-0">
                        {i + 1}
                      </div>
                      <div className="flex-1 space-y-2">
                        <div className="flex gap-2">
                          <div className="flex-1">
                            <div className="flex items-center gap-2 text-xs text-text-muted mb-1">
                              <Clock className="w-3 h-3" />
                              <input
                                type="number"
                                step="0.5"
                                min="0"
                                value={seg.startTime}
                                onChange={(e) => updateSegment(seg.id, 'startTime', parseFloat(e.target.value))}
                                className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                              />
                              <span>→</span>
                              <input
                                type="number"
                                step="0.5"
                                min="0"
                                value={seg.endTime}
                                onChange={(e) => updateSegment(seg.id, 'endTime', parseFloat(e.target.value))}
                                className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                              />
                              <span className="text-text-disabled">({(seg.endTime - seg.startTime).toFixed(1)}s)</span>
                            </div>
                          </div>
                          {segmentInputs.length > 1 && (
                            <button
                              onClick={() => removeSegment(seg.id)}
                              className="p-1 text-text-muted hover:text-accent-red"
                            >
                              <X className="w-4 h-4" />
                            </button>
                          )}
                        </div>
                        <textarea
                          value={seg.description}
                          onChange={(e) => updateSegment(seg.id, 'description', e.target.value)}
                          placeholder="Describe what happens in this segment..."
                          rows={2}
                          className="input-base w-full text-sm resize-none"
                        />
                      </div>
                    </div>
                  </motion.div>
                ))}
              </div>
            </div>
          )}

          {/* Generation Progress Panel */}
          {isGeneratingScript && generationProgress && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="console-card p-4 border-l-4 border-l-accent-red"
            >
              <div className="flex items-center gap-3 mb-3">
                <Loader2 className="w-5 h-5 text-accent-red animate-spin" />
                <div className="flex-1">
                  <h4 className="font-medium text-sm">{generationProgress.message}</h4>
                  {generationProgress.detail && (
                    <p className="text-xs text-text-muted mt-0.5">{generationProgress.detail}</p>
                  )}
                </div>
                <span className="text-xs text-text-muted font-mono">
                  {generationProgress.progress}%
                </span>
              </div>

              {/* Progress bar */}
              <div className="h-2 bg-terminal-bg rounded-full overflow-hidden mb-3">
                <motion.div
                  className="h-full bg-accent-red"
                  initial={{ width: 0 }}
                  animate={{ width: `${generationProgress.progress}%` }}
                  transition={{ duration: 0.3 }}
                />
              </div>

              {/* Stage indicators */}
              <div className="flex items-center gap-4 text-xs text-text-muted">
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'analyzing_video' || generationProgress.stage === 'crafting_prompt'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 15 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Analyze</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'generating'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 50 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Generate</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'validating'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 65 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Validate</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className={clsx(
                    'w-2 h-2 rounded-full',
                    generationProgress.stage === 'refining'
                      ? 'bg-accent-red animate-pulse'
                      : generationProgress.progress > 90 ? 'bg-green-500' : 'bg-terminal-border'
                  )} />
                  <span>Refine</span>
                </div>
              </div>

              {/* Refinement info */}
              {generationProgress.stage === 'refining' && generationProgress.refinementAttempt > 0 && (
                <div className="mt-2 text-xs text-yellow-500 flex items-center gap-1">
                  <RefreshCw className="w-3 h-3" />
                  <span>
                    Refinement pass {generationProgress.refinementAttempt}/{generationProgress.maxRefinements}
                  </span>
                </div>
              )}
            </motion.div>
          )}

          {/* Auto-Generated Segments (Auto Mode) - Editable */}
          {mode === 'auto' && autoGeneratedSegments.length > 0 && (
            <div>
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <FileText className="w-4 h-4 text-accent-red" />
                  <label className="section-header mb-0">Generated Segments & Scripts</label>
                  <span className="text-xs text-text-muted">(editable)</span>
                </div>
                <button
                  onClick={() => {
                    const lastSeg = autoGeneratedSegments[autoGeneratedSegments.length - 1]
                    const newStart = lastSeg ? lastSeg.end_time : 0
                    const newEnd = Math.min(newStart + 15, videoDuration)
                    if (newStart < videoDuration) {
                      setAutoGeneratedSegments([
                        ...autoGeneratedSegments,
                        {
                          segment_index: autoGeneratedSegments.length,
                          name: `Segment ${autoGeneratedSegments.length + 1}`,
                          start_time: newStart,
                          end_time: newEnd,
                          description: '',
                          script: '',
                          word_count: 0,
                          estimated_duration: 0,
                          fits_duration: true,
                        },
                      ])
                    }
                  }}
                  className="btn-secondary text-xs py-1 px-2 flex items-center gap-1"
                >
                  <Plus className="w-3 h-3" />
                  Add Segment
                </button>
              </div>

              <div className="space-y-3">
                {autoGeneratedSegments.map((seg, i) => (
                  <motion.div
                    key={i}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: i * 0.05 }}
                    className={clsx(
                      'console-card p-3 border-l-4',
                      seg.fits_duration ? 'border-l-green-500' : 'border-l-yellow-500'
                    )}
                  >
                    {/* Header row with name and timing inputs */}
                    <div className="flex items-start gap-3 mb-3">
                      <div className="w-8 h-8 rounded bg-green-500/20 flex items-center justify-center text-green-500 font-mono text-sm shrink-0">
                        {i + 1}
                      </div>
                      <div className="flex-1">
                        <div className="flex items-center gap-3 flex-wrap">
                          {/* Segment name */}
                          <input
                            type="text"
                            value={seg.name}
                            onChange={(e) => updateAutoSegment(i, 'name', e.target.value)}
                            className="input-base py-1 px-2 text-sm font-medium w-40"
                            placeholder="Segment name"
                          />
                          {/* Timing controls */}
                          <div className="flex items-center gap-2 text-xs text-text-muted">
                            <Clock className="w-3 h-3" />
                            <input
                              type="number"
                              step="0.5"
                              min="0"
                              max={videoDuration}
                              value={seg.start_time}
                              onChange={(e) => updateAutoSegment(i, 'start_time', parseFloat(e.target.value) || 0)}
                              className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                            />
                            <span>→</span>
                            <input
                              type="number"
                              step="0.5"
                              min="0"
                              max={videoDuration}
                              value={seg.end_time}
                              onChange={(e) => updateAutoSegment(i, 'end_time', parseFloat(e.target.value) || 0)}
                              className="w-16 input-base py-0.5 px-1 text-xs font-mono"
                            />
                            <span className="text-text-disabled">({(seg.end_time - seg.start_time).toFixed(1)}s)</span>
                          </div>
                          {/* Stats */}
                          <div className="flex items-center gap-2 text-xs text-text-muted ml-auto">
                            <span>{seg.word_count} words</span>
                            <span>~{seg.estimated_duration.toFixed(1)}s</span>
                            {seg.fits_duration ? (
                              <Check className="w-4 h-4 text-green-500" />
                            ) : (
                              <span title="Script may not fit duration">
                              <AlertTriangle className="w-4 h-4 text-yellow-500" />
                            </span>
                            )}
                          </div>
                          {/* Delete button */}
                          {autoGeneratedSegments.length > 1 && (
                            <button
                              onClick={() => removeAutoSegment(i)}
                              className="p-1 text-text-muted hover:text-accent-red transition-colors"
                              title="Remove segment"
                            >
                              <Trash2 className="w-4 h-4" />
                            </button>
                          )}
                        </div>
                      </div>
                    </div>

                    {/* Script textarea - editable */}
                    <div className="ml-11">
                      <textarea
                        value={seg.script}
                        onChange={(e) => {
                          const newScript = e.target.value
                          const wordCount = newScript.trim().split(/\s+/).filter(Boolean).length
                          const estimatedDuration = wordCount / 2.5 // ~150 words per minute
                          setAutoGeneratedSegments(
                            autoGeneratedSegments.map((s, idx) =>
                              idx === i
                                ? {
                                    ...s,
                                    script: newScript,
                                    word_count: wordCount,
                                    estimated_duration: estimatedDuration,
                                    fits_duration: estimatedDuration <= (s.end_time - s.start_time),
                                  }
                                : s
                            )
                          )
                        }}
                        placeholder="Enter narration script for this segment..."
                        rows={3}
                        className="input-base w-full text-sm resize-none"
                      />
                      {seg.description && (
                        <p className="text-xs text-text-muted italic mt-1 flex items-center gap-1">
                          <Edit3 className="w-3 h-3" />
                          AI suggestion: {seg.description}
                        </p>
                      )}
                    </div>
                  </motion.div>
                ))}
              </div>
            </div>
          )}

          {/* Generated Scripts (Manual Mode) */}
          {mode === 'manual' && generatedScripts.length > 0 && (
            <div>
              <div className="flex items-center gap-2 mb-3">
                <FileText className="w-4 h-4 text-accent-red" />
                <label className="section-header mb-0">Generated Scripts</label>
              </div>

              <div className="space-y-3">
                {generatedScripts.map((script, i) => (
                  <motion.div
                    key={i}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: i * 0.1 }}
                    className={clsx(
                      'console-card p-3 border-l-4',
                      script.fits_duration ? 'border-l-green-500' : 'border-l-yellow-500'
                    )}
                  >
                    <div className="flex items-center justify-between text-xs text-text-muted mb-2">
                      <span>Segment {script.segment_index + 1}</span>
                      <div className="flex items-center gap-2">
                        <span>{script.word_count} words</span>
                        <span>~{script.estimated_duration.toFixed(1)}s</span>
                        {script.fits_duration ? (
                          <Check className="w-4 h-4 text-green-500" />
                        ) : (
                          <AlertTriangle className="w-4 h-4 text-yellow-500" />
                        )}
                      </div>
                    </div>
                    <p className="text-sm">{script.text}</p>
                  </motion.div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-terminal-border bg-terminal-bg/50 flex items-center justify-between">
          <div className="text-xs text-text-muted">
            {mode === 'auto' ? (
              autoGeneratedSegments.length > 0 ? (
                <>
                  {autoGeneratedSegments.length} segment{autoGeneratedSegments.length !== 1 ? 's' : ''} •{' '}
                  {autoGeneratedSegments.reduce((acc, s) => acc + (s.end_time - s.start_time), 0).toFixed(1)}s total
                </>
              ) : (
                <>Video: {effectiveDuration.toFixed(1)}s</>
              )
            ) : (
              <>
                {segmentInputs.length} segment{segmentInputs.length !== 1 ? 's' : ''} •{' '}
                {segmentInputs.reduce((acc, s) => acc + (s.endTime - s.startTime), 0).toFixed(1)}s total
              </>
            )}
          </div>

          <div className="flex items-center gap-2">
            {/* Auto Mode Buttons */}
            {mode === 'auto' && (
              <>
                {autoGeneratedSegments.length > 0 && (
                  <button
                    onClick={() => handleActionWithOverrideCheck('auto')}
                    disabled={isGeneratingScript}
                    className="btn-secondary flex items-center gap-2"
                  >
                    <RefreshCw className="w-4 h-4" />
                    Regenerate
                  </button>
                )}

                {autoGeneratedSegments.length === 0 ? (
                  <button
                    onClick={() => handleActionWithOverrideCheck('auto')}
                    disabled={
                      isGeneratingScript ||
                      !videoDescription.trim() ||
                      (provider === 'ollama' && !ollamaConnected)
                    }
                    className="btn-primary flex items-center gap-2"
                  >
                    {isGeneratingScript ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Wand2 className="w-4 h-4" />
                    )}
                    Auto-Generate Segments
                  </button>
                ) : (
                  <button
                    onClick={() => handleActionWithOverrideCheck('apply')}
                    disabled={applyMutation.isPending}
                    className="btn-primary flex items-center gap-2"
                  >
                    {applyMutation.isPending ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Zap className="w-4 h-4" />
                    )}
                    Apply to Timeline
                  </button>
                )}
              </>
            )}

            {/* Manual Mode Buttons */}
            {mode === 'manual' && (
              <>
                {generatedScripts.length > 0 && (
                  <button
                    onClick={() => generateMutation.mutate()}
                    disabled={isGeneratingScript}
                    className="btn-secondary flex items-center gap-2"
                  >
                    <RefreshCw className="w-4 h-4" />
                    Regenerate
                  </button>
                )}

                {generatedScripts.length === 0 ? (
                  <button
                    onClick={() => generateMutation.mutate()}
                    disabled={
                      isGeneratingScript ||
                      segmentInputs.some((s) => !s.description.trim()) ||
                      (provider === 'ollama' && !ollamaConnected)
                    }
                    className="btn-primary flex items-center gap-2"
                  >
                    {isGeneratingScript ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Wand2 className="w-4 h-4" />
                    )}
                    Generate Scripts
                  </button>
                ) : (
                  <button
                    onClick={() => handleActionWithOverrideCheck('apply')}
                    disabled={applyMutation.isPending}
                    className="btn-primary flex items-center gap-2"
                  >
                    {applyMutation.isPending ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Zap className="w-4 h-4" />
                    )}
                    Apply to Timeline
                  </button>
                )}
              </>
            )}
          </div>
        </div>
      </motion.div>
    </div>
  )
}
